<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BookWise</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="manifest" href="manifest.webmanifest">
<style>
  /* CSS Variables for theming */
  :root {
    --bg: #fafafa;
    --text: #2c3e50;
    --card: #ffffff;
    --accent: #3498db;
    --accent-hover: #2980b9;
    --secondary: #95a5a6;
    --success: #27ae60;
    --warning: #f39c12;
    --danger: #e74c3c;
    --border: #e1e8ed;
    --shadow: 0 2px 8px rgba(0,0,0,0.1);
    --shadow-hover: 0 4px 16px rgba(0,0,0,0.15);
    --radius: 8px;
    --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
  }
  
  [data-theme="dark"] {
    --bg: #1a1a1a;
    --text: #e8e6e3;
    --card: #2d2d2d;
    --accent: #4a9eff;
    --accent-hover: #357abd;
    --secondary: #6c7b7f;
    --success: #2ecc71;
    --warning: #f1c40f;
    --danger: #e67e22;
    --border: #404040;
    --shadow: 0 2px 8px rgba(0,0,0,0.3);
    --shadow-hover: 0 4px 16px rgba(0,0,0,0.4);
  }

  /* Base styles - Mobile First */
  * {
    box-sizing: border-box;
  }
  
  body {
    margin: 0;
    padding: 16px;
    font-family: var(--font-family);
    background: var(--bg);
    color: var(--text);
    transition: all 0.3s ease;
    line-height: 1.6;
    font-size: 16px; /* Minimum 16px for mobile to prevent zoom */
  }
  
  h1 {
    margin-top: 0;
    margin-bottom: 24px;
    font-size: 1.75rem; /* Smaller on mobile */
    font-weight: 700;
    color: var(--accent);
    text-align: center;
    letter-spacing: -0.02em;
  }
  
  h2 {
    margin-top: 0;
    margin-bottom: 16px;
    font-size: 1.25rem; /* Smaller on mobile */
    font-weight: 600;
    color: var(--text);
  }

  /* Buttons - Mobile First */
  button, select, input[type=file] {
    margin: 4px 0; /* Vertical stacking on mobile */
    padding: 16px 20px; /* Larger touch targets */
    font-size: 16px; /* Minimum 16px for mobile */
    font-family: var(--font-family);
    font-weight: 500;
    border: 2px solid var(--border);
    border-radius: var(--radius);
    background: var(--card);
    color: var(--text);
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: var(--shadow);
    outline: none;
    width: 100%; /* Full width on mobile */
    min-height: 48px; /* Minimum touch target size */
    display: block;
  }
  
  button:hover, select:hover {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
    box-shadow: var(--shadow-hover);
    transform: translateY(-1px);
  }
  
  button:active {
    transform: translateY(0);
    box-shadow: var(--shadow);
  }
  
  button:focus {
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
  }

  /* Input styles - Mobile optimized */
  input[type="text"], input[type="number"], input[type="email"], input[type="search"], 
  textarea, select {
    padding: 18px 20px; /* Larger padding for mobile */
    font-size: 16px; /* Minimum 16px for mobile */
    font-family: var(--font-family);
    border: 2px solid var(--border);
    border-radius: var(--radius);
    background: var(--card);
    color: var(--text);
    transition: all 0.2s ease;
    outline: none;
    width: 100%;
    min-height: 56px; /* Larger minimum height for easier tapping */
    margin-bottom: 16px; /* More spacing between inputs */
    box-sizing: border-box;
  }
  
  /* Enhanced focus states for better visibility */
  input[type="text"]:focus, input[type="number"]:focus, input[type="email"]:focus, 
  input[type="search"]:focus, textarea:focus, select:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.15);
    transform: translateY(-1px);
  }
  
  /* Select dropdown improvements */
  select {
    appearance: none;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
    background-position: right 16px center;
    background-repeat: no-repeat;
    background-size: 16px;
    padding-right: 48px;
    cursor: pointer;
  }
  
  /* Label improvements for mobile */
  label {
    display: block;
    font-weight: 500;
    color: var(--text);
    margin-bottom: 8px;
    font-size: 16px;
    line-height: 1.4;
  }
  
  /* Form container improvements */
  form {
    background: var(--card);
    padding: 24px; /* More padding on mobile */
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    margin: 20px 0;
  }
  
  /* Improved spacing between form elements */
  .form-group {
    margin-bottom: 20px;
  }
  
  .form-row {
    display: flex;
    gap: 16px;
    margin-bottom: 20px;
  }
  
  .form-row > * {
    flex: 1;
    margin-bottom: 0;
  }
  
  /* Placeholder text styling */
  input::placeholder, textarea::placeholder {
    color: var(--secondary);
    opacity: 0.8;
  }
  
  /* Input validation states */
  input:invalid {
    border-color: var(--danger);
  }
  
  input:valid {
    border-color: var(--success);
  }
  
  /* Search input specific styling */
  input[type="search"] {
    border-radius: 28px; /* More rounded for search */
    padding-left: 24px;
    padding-right: 24px;
  }
  
  /* Textarea specific improvements */
  textarea {
    min-height: 120px;
    resize: vertical;
    line-height: 1.5;
  }

  /* Book cards - Mobile optimized */
  .book-card {
    border: 2px solid var(--border);
    background: var(--card);
    padding: 16px; /* Slightly less padding on mobile */
    margin-bottom: 16px;
    width: 100%; /* Full width on mobile */
    max-width: none; /* Remove max-width on mobile */
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  
  .book-card:hover {
    box-shadow: var(--shadow-hover);
    transform: translateY(-2px);
    border-color: var(--accent);
  }
  
  .book-card img {
    border-radius: calc(var(--radius) / 2);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    max-width: 80px; /* Smaller images on mobile */
    height: auto;
  }

  /* Flex containers - Mobile stacked */
  .flex {
    display: flex;
    flex-direction: column; /* Stack vertically on mobile */
    margin-bottom: 16px;
    gap: 8px; /* Smaller gap on mobile */
  }
  
  .flex input {
    width: 100%; /* Full width inputs */
    margin-bottom: 8px;
  }

  /* Tabs - Mobile optimized */
  #tabBar {
    display: flex;
    flex-direction: column; /* Stack tabs vertically on mobile */
    gap: 4px;
    margin-bottom: 20px;
    padding: 12px;
    background: var(--card);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
  }
  
  .tab-btn {
    background: transparent;
    border: 2px solid transparent;
    border-radius: calc(var(--radius) - 2px);
    cursor: pointer;
    font-weight: 500;
    margin: 0;
    padding: 16px 20px; /* Larger touch targets */
    transition: all 0.2s ease;
    box-shadow: none;
    width: 100%;
    min-height: 48px;
    text-align: center;
    font-size: 16px;
  }
  
  .tab-btn:hover {
    background: var(--border);
    transform: none;
  }
  
  .tab-btn.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
    box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
  }
  
  .tab-btn.active:hover {
    background: var(--accent-hover);
    border-color: var(--accent-hover);
  }

  .tab {
    display: none;
    animation: fadeIn 0.3s ease;
  }
  
  .tab.active {
    display: block;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Theme toggle - Mobile positioned */
  #themeToggle {
    background: var(--secondary);
    color: white;
    border-color: var(--secondary);
    order: -1; /* Move to top on mobile */
  }
  
  #themeToggle:hover {
    background: var(--accent);
    border-color: var(--accent);
  }

  /* History search dropdown - Mobile optimized */
  #searchResults {
    border: 2px solid var(--border);
    max-height: 250px; /* Smaller on mobile */
    overflow-y: auto;
    background: var(--card);
    position: absolute;
    left: 0;
    right: 0;
    z-index: 10;
    display: none;
    border-radius: 0 0 var(--radius) var(--radius);
    box-shadow: var(--shadow-hover);
    margin-top: 2px;
  }
  
  .sr-item {
    display: flex;
    gap: 12px;
    padding: 16px 12px; /* Larger touch targets */
    cursor: pointer;
    border-bottom: 1px solid var(--border);
    transition: background 0.2s ease;
    min-height: 60px; /* Ensure adequate touch target */
  }
  
  .sr-item:hover {
    background: var(--border);
  }
  
  .sr-item:last-child {
    border-bottom: none;
    border-radius: 0 0 var(--radius) var(--radius);
  }
  
  .sr-item img {
    height: 50px; /* Smaller on mobile */
    width: auto;
    border-radius: calc(var(--radius) / 2);
    flex-shrink: 0;
  }
  
  .sr-item div {
    flex: 1;
    min-width: 0; /* Allow text to truncate */
  }

  /* Status messages - Mobile optimized */
  .status-message {
    padding: 16px;
    border-radius: var(--radius);
    margin: 16px 0;
    font-weight: 500;
    font-size: 16px;
  }
  
  .status-success {
    background: rgba(39, 174, 96, 0.1);
    color: var(--success);
    border: 2px solid rgba(39, 174, 96, 0.2);
  }
  
  .status-warning {
    background: rgba(243, 156, 18, 0.1);
    color: var(--warning);
    border: 2px solid rgba(243, 156, 18, 0.2);
  }
  
  .status-error {
    background: rgba(231, 76, 60, 0.1);
    color: var(--danger);
    border: 2px solid rgba(231, 76, 60, 0.2);
  }

  /* Score styling - Mobile optimized */
  .score-display {
    font-weight: 600;
    color: var(--accent);
    cursor: pointer;
    text-decoration: underline;
    transition: color 0.2s ease;
    min-height: 44px; /* Adequate touch target */
    display: inline-block;
    padding: 8px;
  }
  
  .score-display:hover {
    color: var(--accent-hover);
  }

  /* Form elements - Mobile optimized */
  form {
    background: var(--card);
    padding: 16px;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    margin: 16px 0;
  }

  /* Remove button styling - Mobile optimized */
  .remove-btn {
    background: var(--danger);
    color: white;
    border-color: var(--danger);
    padding: 12px 16px; /* Larger touch target */
    font-size: 16px;
    min-width: 48px;
    min-height: 48px;
    margin: 8px 0 0 0;
    width: 100%; /* Full width on mobile */
  }
  
  .remove-btn:hover {
    background: #c0392b;
    border-color: #c0392b;
  }

  /* Button groups - Mobile stacked */
  #topBar {
    display: flex;
    flex-direction: column; /* Stack buttons vertically */
    gap: 8px;
    margin-bottom: 16px;
  }
  
  #topBar button {
    width: 100%;
    margin: 0;
  }

  /* Book display flex - Mobile optimized */
  .book-display {
    display: flex;
    flex-direction: column; /* Stack on mobile */
    gap: 12px;
    align-items: flex-start;
  }
  
  .book-info {
    flex: 1;
    min-width: 0;
  }
  
  .book-image {
    flex-shrink: 0;
    align-self: center;
  }

  /* Tablet and up styles */
  @media (min-width: 768px) {
    body {
      padding: 24px;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 32px;
    }
    
    h2 {
      font-size: 1.5rem;
      margin-bottom: 20px;
    }
    
    .book-card {
      max-width: 480px;
      padding: 20px;
    }
    
    .book-card img {
      max-width: 120px;
    }
    
    #tabBar {
      flex-direction: row;
      gap: 8px;
    }
    
    .tab-btn {
      width: auto;
      flex: 1;
    }
    
    #themeToggle {
      margin-left: auto;
      order: 0;
      width: auto;
      flex: 0 0 auto;
    }
    
    .flex {
      flex-direction: row;
      align-items: center;
      gap: 12px;
    }
    
    .flex input {
      margin-bottom: 0;
    }
    
    .remove-btn {
      width: auto;
      min-width: 48px;
      margin: 0;
    }
    
    #topBar {
      flex-direction: row;
      flex-wrap: wrap;
    }
    
    #topBar button {
      width: auto;
      flex: 0 0 auto;
    }
    
    .book-display {
      flex-direction: row;
      align-items: flex-start;
    }
    
    .book-image {
      align-self: flex-start;
    }
    
    .sr-item img {
      height: 60px;
    }
    
    #searchResults {
      max-height: 280px;
    }
  }

  /* Desktop styles */
  @media (min-width: 1024px) {
    body {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px;
    }
    
    .book-card {
      max-width: 600px;
    }
    
    button, select, input[type=file] {
      width: auto;
      display: inline-block;
      margin: 6px 4px;
    }
    
    #topBar button {
      margin: 6px 4px;
    }
  }

  /* Accessibility improvements */
  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* High contrast mode */
  @media (prefers-contrast: high) {
    :root {
      --border: #000000;
      --shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    
    [data-theme="dark"] {
      --border: #ffffff;
    }
  }

  /* Touch feedback for mobile */
  @media (hover: none) and (pointer: coarse) {
    /* Enhanced touch feedback for mobile devices */
    button:active, .tab-btn:active, .sr-item:active, .book-card:active {
      transform: scale(0.98);
      transition: transform 0.1s ease;
    }
    
    button {
      -webkit-tap-highlight-color: rgba(52, 152, 219, 0.3);
      tap-highlight-color: rgba(52, 152, 219, 0.3);
    }
    
    /* Ripple effect on touch */
    button, .tab-btn {
      position: relative;
      overflow: hidden;
    }
    
    button::before, .tab-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.3s ease, height 0.3s ease;
      pointer-events: none;
    }
    
    button:active::before, .tab-btn:active::before {
      width: 200%;
      height: 200%;
    }
  }

  /* Toast notification system */
  .toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 8px;
    pointer-events: none;
  }
  
  .toast {
    background: var(--card);
    border: 2px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow-hover);
    padding: 16px 20px;
    min-width: 280px;
    max-width: 400px;
    pointer-events: auto;
    transform: translateX(120%);
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    position: relative;
    overflow: hidden;
  }
  
  .toast.show {
    transform: translateX(0);
  }
  
  .toast.hide {
    transform: translateX(120%);
    opacity: 0;
  }
  
  .toast-success {
    border-left: 4px solid var(--success);
  }
  
  .toast-error {
    border-left: 4px solid var(--danger);
  }
  
  .toast-warning {
    border-left: 4px solid var(--warning);
  }
  
  .toast-info {
    border-left: 4px solid var(--accent);
  }
  
  .toast-header {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 0.95em;
  }
  
  .toast-icon {
    margin-right: 8px;
    font-size: 1.2em;
  }
  
  .toast-close {
    margin-left: auto;
    background: none;
    border: none;
    color: var(--secondary);
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    transition: background 0.2s ease;
    font-size: 1.1em;
    line-height: 1;
    width: auto;
    min-height: auto;
    box-shadow: none;
  }
  
  .toast-close:hover {
    background: var(--border);
    color: var(--text);
    transform: none;
  }
  
  .toast-body {
    color: var(--text);
    font-size: 0.9em;
    line-height: 1.4;
  }
  
  .toast-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    background: var(--accent);
    transition: width linear;
    border-radius: 0 0 var(--radius) var(--radius);
  }
  
  .toast-success .toast-progress {
    background: var(--success);
  }
  
  .toast-error .toast-progress {
    background: var(--danger);
  }
  
  .toast-warning .toast-progress {
    background: var(--warning);
  }

  /* Mobile toast adjustments */
  @media (max-width: 768px) {
    .toast-container {
      top: 10px;
      right: 10px;
      left: 10px;
    }
    
    .toast {
      min-width: auto;
      max-width: none;
      width: 100%;
      transform: translateY(-120%);
    }
    
    .toast.show {
      transform: translateY(0);
    }
    
    .toast.hide {
      transform: translateY(-120%);
      opacity: 0;
    }
  }

  /* Button press animation for all devices */
  button:active {
    transform: translateY(1px) scale(0.98);
  }
  
  .book-card:active {
    transform: translateY(1px) scale(0.995);
  }
</style>
</head>
<body>
<h1>BookWise</h1>

<!-- TAB BUTTONS -->
<div id="tabBar">
  <button class="tab-btn" data-tab="scannerTab">📷 Scanner</button>
  <button class="tab-btn" data-tab="savedTab">⭐ Saved List</button>
  <button class="tab-btn" data-tab="historyTab">📚 Reading History</button>
  <button id="themeToggle" style="margin-left:auto">🌙 Dark Mode</button>
</div>

<!-- ============ SCANNER TAB ============ -->
<div id="scannerTab" class="tab active">
  <div id="topBar" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px">
    <!-- Hidden inputs -->
    <input type="file" id="imageInput" accept="image/*" style="display:none">
    <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">
    <!-- Visible buttons -->
    <button id="uploadBtn">📁 Upload Photo</button>
    <button id="cameraBtn">📷 Take Photo</button>
  </div>

  <p id="statusMsg"></p>
  <pre id="output"></pre>
  <div id="results"></div>
</div>

<!-- ============ SAVED LIST TAB ============ -->
<div id="savedTab" class="tab">
  <h2>My Saved List</h2>
  <div id="savedControls"></div>
  <div id="savedList"></div>
</div>

<!-- ============ READING HISTORY TAB ============ -->
<div id="historyTab" class="tab">
  <h2>Books I've Read</h2>

  <!-- Import Section -->
  <div style="max-width:420px;margin-bottom:15px;padding:10px;background:var(--card);border-radius:5px;">
    <h3 style="margin-top:0;">Import from CSV</h3>
    <p style="margin:5px 0;font-size:0.9em;color:var(--text);">
      Import your reading history from Goodreads or other services. 
      <a href="#" onclick="showCSVFormat()" style="color:var(--accent);">See expected format</a>
    </p>
    <input type="file" id="csvInput" accept=".csv,.txt" style="display:none">
    <button id="importBtn" style="margin-right:10px;">📁 Import CSV File</button>
    <button id="exportHistoryBtn">📄 Export My History</button>
  </div>

  <!-- Live Search Input -->
  <div style="max-width:500px;margin-bottom:20px;position:relative">
    <label for="bookSearch" style="display: block; margin-bottom: 8px; font-weight: 500;">Search by Title:</label>
    <input type="search" id="bookSearch" placeholder="Search books to add (e.g., The Hobbit)" style="width:100%" autocomplete="off" autocapitalize="words">
    <div id="searchResults"></div>
  </div>

  <!-- Manual entry / auto‑fill form -->
  <form id="historyForm" class="mobile-form" style="max-width:500px">
    <div class="form-group">
      <label for="bookTitle">Book Title *</label>
      <input type="text" id="bookTitle" name="title" placeholder="Enter book title" required autocomplete="off" autocapitalize="words">
    </div>
    
    <div class="form-row">
      <div class="form-group">
        <label for="bookAuthor">Author</label>
        <input type="text" id="bookAuthor" name="author" placeholder="Author name" autocomplete="off" autocapitalize="words">
      </div>
      
      <div class="form-group">
        <label for="bookRating">Your Rating</label>
        <select id="bookRating" name="rating">
          <option value="5">★★★★★ Amazing (5)</option>
          <option value="4.5">★★★★☆ Excellent (4.5)</option>
          <option value="4">★★★★☆ Great (4)</option>
          <option value="3.5">★★★☆☆ Good (3.5)</option>
          <option value="3" selected>★★★☆☆ Okay (3)</option>
          <option value="2.5">★★☆☆☆ Fair (2.5)</option>
          <option value="2">★★☆☆☆ Poor (2)</option>
          <option value="1.5">★☆☆☆☆ Bad (1.5)</option>
          <option value="1">★☆☆☆☆ Terrible (1)</option>
          <option value="0.5">☆☆☆☆☆ Awful (0.5)</option>
        </select>
      </div>
    </div>
    
    <div class="form-group">
      <label for="bookGenre">Genres</label>
      <input type="text" id="bookGenre" name="genre" placeholder="e.g., Fiction, Mystery, Romance" autocomplete="off" autocapitalize="words">
      <small style="color: var(--secondary); font-size: 14px; margin-top: 4px; display: block;">Separate multiple genres with commas</small>
    </div>
    
    <button type="submit" style="width: 100%; margin-top: 8px; font-size: 16px; font-weight: 600;">📚 Add to Reading History</button>
  </form>

  <div id="historyList" style="margin-top:15px"></div>
</div>

<!-- *****  REPLACE WITH YOUR REAL KEY  ***** -->
<script>const API_KEY="AIzaSyAVbYZOoKpBB3IQhluruE1jQsjJ0SZdZPw";</script>

<script>
/* ========== THEME TOGGLE ========== */
const prefersDark=matchMedia("(prefers-color-scheme:dark)").matches;
document.documentElement.dataset.theme=
  localStorage.getItem("theme")|| (prefersDark?"dark":"light");
const themeBtn=document.getElementById("themeToggle");
const updateThemeButton=()=>
  themeBtn.textContent=document.documentElement.dataset.theme==="dark"?"☀️ Light Mode":"🌙 Dark Mode";
updateThemeButton();
themeBtn.onclick = enhancedClick(themeBtn, ()=>{
  const newTheme = document.documentElement.dataset.theme==="dark"?"light":"dark";
  document.documentElement.dataset.theme = newTheme;
  localStorage.setItem("theme", newTheme);
  updateThemeButton();
  showToast(`Switched to ${newTheme} mode`, 'info', 2000);
  hapticFeedback('light');
}, 'light');

/* ========== TAB SWITCHING ========== */
document.querySelectorAll(".tab-btn").forEach(btn=>{
  btn.onclick=()=>{
    document.querySelectorAll(".tab-btn").forEach(b=>b.classList.remove("active"));
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    btn.classList.add("active");
    document.getElementById(btn.dataset.tab).classList.add("active");
  };
});

/* ========== BUTTON TRIGGERS (Scanner) ========== */
document.getElementById("uploadBtn").onclick = enhancedClick(
  document.getElementById("uploadBtn"),
  () => document.getElementById("imageInput").click(),
  'light'
);

document.getElementById("cameraBtn").onclick = enhancedClick(
  document.getElementById("cameraBtn"),
  () => document.getElementById("cameraInput").click(),
  'light'
);

document.getElementById("importBtn").onclick = enhancedClick(
  document.getElementById("importBtn"),
  () => document.getElementById("csvInput").click(),
  'light'
);

document.getElementById("exportHistoryBtn").onclick = enhancedClick(
  document.getElementById("exportHistoryBtn"),
  exportHistory,
  'light'
);

["imageInput","cameraInput"].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener("change",e=>{processImage(e).then(()=>el.value="");});
});

document.getElementById("csvInput").addEventListener("change",e=>{
  importCSV(e).then(()=>{
    e.target.value="";
    showToast("CSV file imported successfully!", 'success');
    hapticFeedback('success');
  }).catch(err=>{
    console.error(err);
    showToast("Failed to import CSV file. Please check the file format.", 'error');
  });
});

/* ========== TOAST NOTIFICATION SYSTEM ========== */

// Create toast container if it doesn't exist
function getToastContainer() {
  let container = document.getElementById('toast-container');
  if (!container) {
    container = document.createElement('div');
    container.id = 'toast-container';
    container.className = 'toast-container';
    document.body.appendChild(container);
  }
  return container;
}

// Show toast notification
function showToast(message, type = 'info', duration = 4000) {
  const container = getToastContainer();
  
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  
  const icons = {
    success: '✅',
    error: '❌',
    warning: '⚠️',
    info: 'ℹ️'
  };
  
  const titles = {
    success: 'Success',
    error: 'Error',
    warning: 'Warning',
    info: 'Info'
  };
  
  toast.innerHTML = `
    <div class="toast-header">
      <span class="toast-icon">${icons[type]}</span>
      <span>${titles[type]}</span>
      <button class="toast-close" onclick="hideToast(this.closest('.toast'))">&times;</button>
    </div>
    <div class="toast-body">${message}</div>
    <div class="toast-progress"></div>
  `;
  
  container.appendChild(toast);
  
  // Trigger animation
  setTimeout(() => toast.classList.add('show'), 10);
  
  // Progress bar animation
  const progressBar = toast.querySelector('.toast-progress');
  progressBar.style.width = '100%';
  setTimeout(() => {
    progressBar.style.width = '0%';
    progressBar.style.transitionDuration = `${duration}ms`;
  }, 100);
  
  // Auto-hide
  const hideTimeout = setTimeout(() => {
    hideToast(toast);
  }, duration);
  
  // Pause on hover (for desktop)
  toast.addEventListener('mouseenter', () => {
    clearTimeout(hideTimeout);
    progressBar.style.animationPlayState = 'paused';
  });
  
  toast.addEventListener('mouseleave', () => {
    hideToast(toast);
  });
  
  return toast;
}

// Hide toast notification
function hideToast(toast) {
  if (!toast || toast.classList.contains('hide')) return;
  
  toast.classList.add('hide');
  setTimeout(() => {
    if (toast.parentNode) {
      toast.parentNode.removeChild(toast);
    }
  }, 300);
}

// Hide all toasts
function hideAllToasts() {
  const toasts = document.querySelectorAll('.toast');
  toasts.forEach(hideToast);
}

/* ========== HAPTIC FEEDBACK (for supported devices) ========== */

// Add haptic feedback for supported devices
function hapticFeedback(type = 'light') {
  if (navigator.vibrate) {
    const patterns = {
      light: [10],
      medium: [20],
      heavy: [30],
      success: [10, 50, 10],
      error: [100, 50, 100]
    };
    navigator.vibrate(patterns[type] || patterns.light);
  }
}

// Enhanced button click handler with feedback
function enhancedClick(element, callback, feedbackType = 'light') {
  return function(event) {
    // Add haptic feedback
    hapticFeedback(feedbackType);
    
    // Add visual ripple effect for non-CSS supported devices
    if (!window.CSS || !CSS.supports('pointer', 'coarse')) {
      addRippleEffect(element, event);
    }
    
    // Execute callback
    if (callback) {
      return callback.call(this, event);
    }
  };
}

// Create ripple effect for button feedback
function addRippleEffect(element, event) {
  const ripple = document.createElement('span');
  const rect = element.getBoundingClientRect();
  const size = Math.max(rect.width, rect.height);
  const x = event.clientX - rect.left - size / 2;
  const y = event.clientY - rect.top - size / 2;
  
  ripple.style.cssText = `
    position: absolute;
    border-radius: 50%;
    transform: scale(0);
    animation: ripple 0.6s linear;
    background-color: rgba(255, 255, 255, 0.3);
    width: ${size}px;
    height: ${size}px;
    left: ${x}px;
    top: ${y}px;
    pointer-events: none;
  `;
  
  element.style.position = 'relative';
  element.style.overflow = 'hidden';
  element.appendChild(ripple);
  
  setTimeout(() => {
    if (ripple.parentNode) {
      ripple.parentNode.removeChild(ripple);
    }
  }, 600);
}

// Add ripple animation to head if not exists
if (!document.getElementById('ripple-animation')) {
  const rippleCSS = document.createElement('style');
  rippleCSS.id = 'ripple-animation';
  rippleCSS.textContent = `
    @keyframes ripple {
      to {
        transform: scale(4);
        opacity: 0;
      }
    }
  `;
  document.head.appendChild(rippleCSS);
}

/* ========== OCR TEXT PROCESSING FUNCTIONS ========== */

// Clean and filter OCR lines to remove noise
function cleanOCRLines(rawLines) {
  const debugLog = { discarded: [], cleaned: [] };
  
  // Common stopwords and noise patterns
  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
    'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',
    'will', 'would', 'could', 'should', 'may', 'might', 'must', 'this', 'that', 'these', 'those'
  ]);
  
  const noisePatterns = [
    /^(isbn|copyright|©|\d{4}|\$\d+|\d+\.\d+)$/i, // ISBNs, years, prices
    /^(page|chapter|part|volume|vol|edition|ed)\s*\d*$/i, // Book structure terms
    /^(illustrated|adapted|abridged|unabridged|revised)$/i, // Publication terms
    /^(hardcover|paperback|kindle|ebook|audiobook)$/i, // Format terms
    /^(bestseller|award|winner|nominee|finalist)$/i, // Marketing terms
    /^(new|york|times|amazon|goodreads|review)$/i, // Publisher/review terms
    /^[^\w\s]+$/, // Only punctuation
    /^\d+$/ // Only numbers
  ];
  
  const cleaned = rawLines
    .map(line => line.trim())
    .filter(line => {
      // Remove very short lines
      if (line.length < 3) {
        debugLog.discarded.push({ line, reason: 'too short' });
        return false;
      }
      
      // Remove lines with only stopwords
      const words = line.toLowerCase().split(/\s+/);
      if (words.every(word => stopWords.has(word))) {
        debugLog.discarded.push({ line, reason: 'only stopwords' });
        return false;
      }
      
      // Remove lines matching noise patterns
      for (const pattern of noisePatterns) {
        if (pattern.test(line)) {
          debugLog.discarded.push({ line, reason: 'noise pattern' });
          return false;
        }
      }
      
      return true;
    })
    // Remove near-duplicates (Levenshtein distance)
    .filter((line, index, arr) => {
      const isDuplicate = arr.slice(0, index).some(prevLine => 
        calculateSimilarity(line.toLowerCase(), prevLine.toLowerCase()) > 0.8
      );
      if (isDuplicate) {
        debugLog.discarded.push({ line, reason: 'near duplicate' });
        return false;
      }
      debugLog.cleaned.push(line);
      return true;
    });
  
  return { lines: cleaned, debug: debugLog };
}

// Calculate text similarity using Levenshtein distance
function calculateSimilarity(str1, str2) {
  const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
  
  for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
  for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
  
  for (let j = 1; j <= str2.length; j++) {
    for (let i = 1; i <= str1.length; i++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i - 1] + 1,     // insertion
        matrix[j - 1][i] + 1,     // deletion
        matrix[j - 1][i - 1] + cost // substitution
      );
    }
  }
  
  const maxLen = Math.max(str1.length, str2.length);
  return maxLen === 0 ? 1 : 1 - (matrix[str2.length][str1.length] / maxLen);
}

// Group related OCR lines into potential book titles
function groupOCRLines(cleanedLines) {
  const debugLog = { groups: [], individual: [] };
  const used = new Set();
  const groups = [];
  
  // Look for title + author patterns first
  for (let i = 0; i < cleanedLines.length - 1; i++) {
    if (used.has(i)) continue;
    
    const line1 = cleanedLines[i];
    const line2 = cleanedLines[i + 1];
    
    // Check if line1 looks like a title and line2 looks like an author
    if (looksLikeTitle(line1) && looksLikeAuthor(line2)) {
      const combined = `${line1} by ${line2}`;
      groups.push({
        text: combined,
        confidence: 0.9,
        components: [line1, line2],
        type: 'title-author'
      });
      debugLog.groups.push({
        combined,
        components: [line1, line2],
        type: 'title-author',
        indices: [i, i + 1]
      });
      used.add(i);
      used.add(i + 1);
      continue;
    }
  }
  
  // Look for split titles (nearby lines with matching capitalization)
  for (let i = 0; i < cleanedLines.length - 2; i++) {
    if (used.has(i)) continue;
    
    const candidates = [];
    candidates.push(cleanedLines[i]);
    
    // Look for up to 3 nearby lines that might be part of the same title
    for (let j = i + 1; j < Math.min(i + 4, cleanedLines.length); j++) {
      if (used.has(j)) continue;
      
      const currentLine = cleanedLines[j];
      
      // Check if this line might be part of the same title
      if (mightBeSameTitle(cleanedLines[i], currentLine)) {
        candidates.push(currentLine);
      }
    }
    
    // If we found potential components, try to merge them
    if (candidates.length > 1) {
      const merged = mergeTitle(candidates);
      const confidence = calculateMergeConfidence(candidates, merged);
      
      // Only keep merges with reasonable confidence
      if (confidence > 0.6) {
        groups.push({
          text: merged,
          confidence: confidence,
          components: candidates,
          type: 'split-title'
        });
        
        debugLog.groups.push({
          combined: merged,
          components: candidates,
          type: 'split-title',
          confidence: confidence
        });
        
        // Mark all components as used
        candidates.forEach(component => {
          const index = cleanedLines.indexOf(component);
          if (index !== -1) used.add(index);
        });
        continue;
      }
    }
  }
  
  // Add remaining individual lines
  cleanedLines.forEach((line, index) => {
    if (!used.has(index)) {
      groups.push({
        text: line,
        confidence: looksLikeTitle(line) ? 0.7 : 0.5,
        components: [line],
        type: 'individual'
      });
      debugLog.individual.push({ line, index });
    }
  });
  
  // Sort by confidence (highest first)
  groups.sort((a, b) => b.confidence - a.confidence);
  
  return { groups, debug: debugLog };
}

// Check if a line looks like a book title
function looksLikeTitle(line) {
  const titlePatterns = [
    /^[A-Z][a-z]/, // Starts with capital letter
    /[A-Z][a-z]+(?:\s+[A-Z][a-z]*)*/, // Title case pattern
    /^(the|a|an)\s+[A-Z]/i, // Articles followed by capitals
  ];
  
  const hasNumbers = /\d/.test(line);
  const hasArticles = /^(the|a|an)\s+/i.test(line);
  const reasonableLength = line.length >= 4 && line.length <= 100;
  
  return titlePatterns.some(pattern => pattern.test(line)) && 
         !hasNumbers && reasonableLength;
}

// Check if a line looks like an author name
function looksLikeAuthor(line) {
  const authorPatterns = [
    /^[A-Z][a-z]+(?:\s+[A-Z]\.?)*(?:\s+[A-Z][a-z]+)+$/, // First M. Last or First Last
    /^[A-Z]\.\s*[A-Z]\.\s*[A-Z][a-z]+$/, // J.K. Rowling style
    /^by\s+[A-Z]/i, // Starts with "by"
  ];
  
  const hasCommonNames = /\b(john|jane|mary|david|michael|sarah|elizabeth|robert|william|james)\b/i.test(line);
  const reasonableLength = line.length >= 4 && line.length <= 50;
  
  return (authorPatterns.some(pattern => pattern.test(line)) || hasCommonNames) && 
         reasonableLength;
}

// Check if two lines might be parts of the same title
function mightBeSameTitle(line1, line2) {
  const both = [line1, line2].map(l => l.trim().toUpperCase());
  
  // Similar capitalization patterns
  const cap1 = line1.replace(/[^A-Z]/g, '');
  const cap2 = line2.replace(/[^A-Z]/g, '');
  const similarCaps = cap1.length > 0 && cap2.length > 0 && 
                      Math.abs(cap1.length - cap2.length) <= 1;
  
  // One might be a connecting word or preposition
  const connectingWords = ['of', 'the', 'and', 'in', 'on', 'at', 'to', 'for', 'with'];
  const isConnector = connectingWords.some(word => 
    both[1].includes(word.toUpperCase()) && both[1].split(/\s+/).length <= 2
  );
  
  // Both are short and might be fragments
  const bothShort = line1.length <= 15 && line2.length <= 15;
  
  return similarCaps || isConnector || bothShort;
}

// Merge title components intelligently
function mergeTitle(components) {
  // Sort components by likely order (longer/more complete parts first)
  const sorted = components.slice().sort((a, b) => {
    // Prefer lines that look more like main title parts
    const aScore = looksLikeTitle(a) ? 1 : 0;
    const bScore = looksLikeTitle(b) ? 1 : 0;
    if (aScore !== bScore) return bScore - aScore;
    
    // Then by length
    return b.length - a.length;
  });
  
  // Smart joining - detect if we need connecting words
  let merged = sorted[0];
  for (let i = 1; i < sorted.length; i++) {
    const next = sorted[i];
    
    // Skip if it's already contained in the merged title
    if (merged.toLowerCase().includes(next.toLowerCase())) continue;
    
    // Add connecting words if needed
    const needsConnection = !merged.endsWith(' ') && !next.startsWith(' ') &&
                           !/^(of|the|and|in|on|at|to|for|with)$/i.test(next);
    
    merged += needsConnection ? ` ${next}` : next;
  }
  
  return merged.trim().replace(/\s+/g, ' ');
}

// Calculate confidence for a merged title
function calculateMergeConfidence(components, merged) {
  let confidence = 0.5; // Base confidence
  
  // Boost for title-like appearance of result
  if (looksLikeTitle(merged)) confidence += 0.2;
  
  // Boost for reasonable length
  if (merged.length >= 8 && merged.length <= 80) confidence += 0.1;
  
  // Boost for multiple meaningful components
  if (components.length >= 2) confidence += 0.1;
  if (components.length >= 3) confidence += 0.1;
  
  // Penalty for too many components (likely noise)
  if (components.length > 4) confidence -= 0.2;
  
  return Math.max(0, Math.min(1, confidence));
}

// Main OCR processing function
function processOCRText(rawLines) {
  const cleaning = cleanOCRLines(rawLines);
  const grouping = groupOCRLines(cleaning.lines);
  
  const processed = {
    queries: grouping.groups.map(group => group.text),
    debug: {
      original: rawLines,
      cleaning: cleaning.debug,
      grouping: grouping.debug,
      finalGroups: grouping.groups
    }
  };
  
  return processed;
}

/* ========== IMAGE PROCESSING UTILITIES ========== */

// Compress image for mobile-friendly processing
function compressImage(file, maxWidth = 1200, maxHeight = 1600, quality = 0.8) {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = () => {
      // Calculate new dimensions while maintaining aspect ratio
      let { width, height } = img;
      
      if (width > maxWidth || height > maxHeight) {
        const ratio = Math.min(maxWidth / width, maxHeight / height);
        width *= ratio;
        height *= ratio;
      }
      
      canvas.width = width;
      canvas.height = height;
      
      // Draw and compress
      ctx.drawImage(img, 0, 0, width, height);
      
      // Convert to blob with compression
      canvas.toBlob(resolve, 'image/jpeg', quality);
    };
    
    img.src = URL.createObjectURL(file);
  });
}

// Create image preview element
function createImagePreview(file) {
  const previewContainer = document.createElement('div');
  previewContainer.id = 'imagePreview';
  previewContainer.style.cssText = `
    margin: 16px 0;
    padding: 16px;
    background: var(--card);
    border: 2px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    text-align: center;
  `;
  
  const img = document.createElement('img');
  img.style.cssText = `
    max-width: 100%;
    max-height: 300px;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    display: block;
    margin: 0 auto 12px auto;
  `;
  img.src = URL.createObjectURL(file);
  img.alt = 'Selected image preview';
  
  const info = document.createElement('div');
  info.style.cssText = `
    font-size: 0.9em;
    color: var(--secondary);
    margin-bottom: 12px;
  `;
  
  const fileSize = (file.size / 1024 / 1024).toFixed(2);
  info.textContent = `${file.name} (${fileSize} MB)`;
  
  const buttonContainer = document.createElement('div');
  buttonContainer.style.cssText = `
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
  `;
  
  const processBtn = document.createElement('button');
  processBtn.textContent = '🔍 Process Image';
  processBtn.style.cssText = `
    background: var(--accent);
    color: white;
    border-color: var(--accent);
    margin: 0;
    flex: 1;
    min-width: 120px;
  `;
  
  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = '❌ Cancel';
  cancelBtn.className = 'remove-btn';
  cancelBtn.style.cssText = `
    margin: 0;
    flex: 0 0 auto;
    min-width: 80px;
  `;
  
  cancelBtn.onclick = () => {
    previewContainer.remove();
    document.getElementById('imageInput').value = '';
    document.getElementById('cameraInput').value = '';
  };
  
  buttonContainer.appendChild(processBtn);
  buttonContainer.appendChild(cancelBtn);
  
  previewContainer.appendChild(img);
  previewContainer.appendChild(info);
  previewContainer.appendChild(buttonContainer);
  
  return { container: previewContainer, processBtn };
}

// Create loading spinner
function createLoadingSpinner() {
  const spinner = document.createElement('div');
  spinner.id = 'loadingSpinner';
  spinner.style.cssText = `
    margin: 20px 0;
    padding: 24px;
    background: var(--card);
    border: 2px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    text-align: center;
  `;
  
  const spinnerIcon = document.createElement('div');
  spinnerIcon.style.cssText = `
    width: 40px;
    height: 40px;
    border: 4px solid var(--border);
    border-top: 4px solid var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 16px auto;
  `;
  
  const message = document.createElement('div');
  message.style.cssText = `
    font-size: 1.1em;
    font-weight: 500;
    color: var(--text);
    margin-bottom: 8px;
  `;
  message.textContent = 'Processing Image...';
  
  const subMessage = document.createElement('div');
  subMessage.style.cssText = `
    font-size: 0.9em;
    color: var(--secondary);
  `;
  subMessage.textContent = 'Extracting text with OCR technology';
  
  spinner.appendChild(spinnerIcon);
  spinner.appendChild(message);
  spinner.appendChild(subMessage);
  
  return spinner;
}

// Add CSS animation for spinner
const spinnerStyles = document.createElement('style');
spinnerStyles.textContent = `
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
`;
document.head.appendChild(spinnerStyles);

/* ========== OCR + GOOGLE BOOKS (Scanner) ========== */
async function processImage(e){
  const file = e.target.files[0]; 
  if (!file) return;
  
  // Clear previous results
  const results = document.getElementById("results");
  const output = document.getElementById("output");
  const statusMsg = document.getElementById("statusMsg");
  
  // Remove any existing preview or spinner
  const existingPreview = document.getElementById('imagePreview');
  const existingSpinner = document.getElementById('loadingSpinner');
  if (existingPreview) existingPreview.remove();
  if (existingSpinner) existingSpinner.remove();
  
  results.innerHTML = "";
  output.textContent = "";
  statusMsg.textContent = "";
  
  // Create and show image preview
  const { container: previewContainer, processBtn } = createImagePreview(file);
  results.appendChild(previewContainer);
  
  // Handle process button click
  processBtn.onclick = async () => {
    try {
      // Remove preview and show loading spinner
      previewContainer.remove();
      const spinner = createLoadingSpinner();
      results.appendChild(spinner);
      
      // Compress image for better performance
      const compressedFile = await compressImage(file);
      const compressedSize = (compressedFile.size / 1024 / 1024).toFixed(2);
      console.log(`Image compressed: ${(file.size / 1024 / 1024).toFixed(2)}MB → ${compressedSize}MB`);
      
      // Convert compressed image to base64
      const reader = new FileReader();
      reader.onloadend = async () => {
        try {
          const b64 = reader.result.split(",")[1];
          
          // Update spinner message
          const spinnerMsg = spinner.querySelector('div:nth-child(2)');
          if (spinnerMsg) spinnerMsg.textContent = 'Analyzing text...';
          
          const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${API_KEY}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              requests: [{
                image: { content: b64 },
                features: [{ type: "DOCUMENT_TEXT_DETECTION" }]
              }]
            })
          });
          
          const json = await res.json();
          const blocks = json.responses?.[0]?.fullTextAnnotation?.pages?.[0]?.blocks || [];
          let rawLines = [];
          
          for (const b of blocks) {
            let t = "";
            b.paragraphs.forEach(p => p.words.forEach(w => t += w.symbols.map(s => s.text).join("") + " "));
            t = t.trim();
            if (t.length > 0) rawLines.push(t);
          }
          
          // Update spinner message
          if (spinnerMsg) spinnerMsg.textContent = 'Processing text...';
          
          // Process OCR text with intelligent cleaning and grouping
          const processed = processOCRText(rawLines);
          
          // Remove spinner
          spinner.remove();
          
          // Show results
          output.textContent = processed.queries.join("\n") || "(No text detected)";
          
          // Store debug info for transparency
          window.lastOCRDebug = processed.debug;
          console.log("OCR Processing Debug:", processed.debug);
          
          buildSearchForm(processed.queries, processed.debug);
          
          // Show success toast
          showToast(`Image processed successfully! Found ${processed.queries.length} potential book titles.`, 'success');
          
        } catch (err) {
          console.error(err);
          spinner.remove();
          output.textContent = "OCR error occurred.";
          showToast("Failed to process image. Please try again or use a clearer image.", 'error', 6000);
        }
      };
      
      reader.readAsDataURL(compressedFile);
      
    } catch (err) {
      console.error(err);
      const existingSpinner = document.getElementById('loadingSpinner');
      if (existingSpinner) existingSpinner.remove();
      
      showToast("Failed to process image. Please check your connection and try again.", 'error', 6000);
    }
  };
}

function buildSearchForm(queries, debug){
  const results = document.getElementById("results");
  results.innerHTML="<h2>Processed OCR Results</h2>";
  
  // Add debug toggle if debug info is available
  if (debug) {
    const debugToggle = document.createElement("button");
    debugToggle.type = "button";
    debugToggle.textContent = "Show Processing Details";
    debugToggle.style.cssText = "margin-bottom: 16px; background: var(--secondary); color: white; border-color: var(--secondary);";
    
    const debugInfo = document.createElement("div");
    debugInfo.style.display = "none";
    debugInfo.style.cssText = "background: var(--card); border: 2px solid var(--border); padding: 16px; margin: 16px 0; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 13px; white-space: pre-wrap; border-radius: var(--radius); box-shadow: var(--shadow);";
    
    debugToggle.onclick = () => {
      if (debugInfo.style.display === "none") {
        debugInfo.style.display = "block";
        debugToggle.textContent = "Hide Processing Details";
        
        let debugText = `📊 OCR Processing Summary:\n\n`;
        debugText += `Original lines detected: ${debug.original.length}\n`;
        debugText += `Lines discarded: ${debug.cleaning.discarded.length}\n`;
        debugText += `Lines cleaned: ${debug.cleaning.cleaned.length}\n`;
        debugText += `Final grouped queries: ${queries.length}\n\n`;
        
        if (debug.cleaning.discarded.length > 0) {
          debugText += `🗑️ Discarded lines:\n`;
          debug.cleaning.discarded.forEach(item => {
            debugText += `  • "${item.line}" (${item.reason})\n`;
          });
          debugText += `\n`;
        }
        
        if (debug.grouping.groups.length > 0) {
          debugText += `🔗 Grouped combinations:\n`;
          debug.grouping.groups.forEach(group => {
            debugText += `  • Type: ${group.type}\n`;
            debugText += `    Combined: "${group.combined}"\n`;
            debugText += `    From: [${group.components.join(', ')}]\n`;
            if (group.confidence) debugText += `    Confidence: ${(group.confidence * 100).toFixed(1)}%\n`;
            debugText += `\n`;
          });
        }
        
        if (debug.grouping.individual.length > 0) {
          debugText += `📝 Individual lines kept:\n`;
          debug.grouping.individual.forEach(item => {
            debugText += `  • "${item.line}"\n`;
          });
        }
        
        debugInfo.textContent = debugText;
      } else {
        debugInfo.style.display = "none";
        debugToggle.textContent = "Show Processing Details";
      }
    };
    
    results.appendChild(debugToggle);
    results.appendChild(debugInfo);
  }
  
  const form=document.createElement("form");form.id="searchForm";
  queries.forEach((query,i)=>{
    const wrap=document.createElement("div");wrap.className="flex";wrap.style.cssText="margin: 5px 0; align-items: center;";
    
    const inp=document.createElement("input");
    inp.value=query;
    inp.name=`t${i}`;
    inp.style.flex="1";
    inp.style.marginRight="10px";
    
    const x=document.createElement("button");
    x.type="button";
    x.textContent="❌";
    x.className="remove-btn";
    x.onclick=()=>wrap.remove();
    
    wrap.append(inp,x);
    form.appendChild(wrap);
  });
  
  const submitBtn = document.createElement("button");
  submitBtn.textContent="Search Books";
  submitBtn.style.cssText="margin-top: 10px;";
  form.appendChild(submitBtn);
  
  results.appendChild(form);
}

document.addEventListener("submit",e=>{
  if(e.target.id==="searchForm"){e.preventDefault();
    const titles=[...new FormData(e.target).values()]
      .map(v=>v.trim().replace(/[^\w\s'":,.!?-]/g,"").replace(/\s+/g," "))
      .filter(v=>v.length>2);
    searchBooks([...new Set(titles)]);
  }
  if(e.target.id==="historyForm"){e.preventDefault();addHistoryEntry(new FormData(e.target));}
});

/* ---------- Google Books search for Scanner ---------- */
async function searchBooks(titles){
  const results = document.getElementById("results");
  results.innerHTML="<p>Searching Google Books…</p>";
  const books=[];
  for(const t of titles){
    try{
      const url=`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(t)}&maxResults=1&key=${API_KEY}`;
      const j=await fetch(url).then(r=>r.json());
      const v=j.items?.[0]?.volumeInfo;
      if(v)books.push({title:v.title,authors:(v.authors||[]).join(", "),
        rating:v.averageRating||"N/A",thumb:v.imageLinks?.thumbnail||"",categories:(v.categories||[]).map(c=>c.trim()),query:t});
    }catch(e){console.error(e);}
  }
  showSearchResults(books);
}

function showSearchResults(books){
  // Rank books before rendering
  const rankedBooks = rankScannedBooks(books);
  const results = document.getElementById("results");
  results.innerHTML="<h2>Book Matches</h2>";
  const genres=[...new Set(rankedBooks.flatMap(b=>b.categories))].sort();
  if(genres.length){
    const lab=document.createElement("label");lab.textContent="Filter:";
    const sel=document.createElement("select");sel.id="genreFilter";
    sel.innerHTML="<option value='all'>All</option>"+genres.map(g=>`<option>${g}</option>`).join("");
    sel.onchange=()=>renderCards(rankedBooks);
    results.append(lab,sel);
  }
  const sortSel=document.createElement("select");sortSel.id="sortFilter";
  sortSel.innerHTML=`<option value="rank-desc">Best Match</option>
                     <option value="t-asc">Title A→Z</option>
                     <option value="t-desc">Title Z→A</option>
                     <option value="r-desc">Rating ↑</option>
                     <option value="r-asc">Rating ↓</option>`;
  sortSel.onchange=()=>renderCards(rankedBooks);
  
  const helpLink = document.createElement("a");
  helpLink.href = "#";
  helpLink.textContent = "How does ranking work?";
  helpLink.style.cssText = "margin-left:10px;color:var(--accent);font-size:0.9em;text-decoration:underline;cursor:pointer;";
  helpLink.onclick = (e) => { e.preventDefault(); showRankingHelp(); };
  
  results.append(sortSel, helpLink);
  renderCards(rankedBooks);
}

function renderCards(list){
  const results = document.getElementById("results");
  results.querySelectorAll(".book-card").forEach(n=>n.remove());
  const g=results.querySelector("#genreFilter")?.value||"all";
  const s=results.querySelector("#sortFilter")?.value||"rank-desc";
  let books=[...list]; if(g!=="all")books=books.filter(b=>b.categories.includes(g));
  const sorters={
    "rank-desc":(a,b)=>(b.rankScore||0)-(a.rankScore||0),
    "t-asc":(a,b)=>a.title.localeCompare(b.title),
    "t-desc":(a,b)=>b.title.localeCompare(a.title),
    "r-desc":(a,b)=>(b.rating||0)-(a.rating||0),
    "r-asc":(a,b)=>(a.rating||0)-(b.rating||0)
  };
  books.sort(sorters[s]);
  books.forEach(b=>{
    const c=document.createElement("div");c.className="book-card";
    c.innerHTML=`
      <div class="book-display">
        ${b.thumb ? `<div class="book-image"><img src="${b.thumb}" alt="${b.title} cover"></div>` : ""}
        <div class="book-info">
          <div style="color:var(--secondary);font-size:0.9em;margin-bottom:8px;"><strong>Matched:</strong> "${b.query}"</div>
          <h3 style="margin:0 0 8px 0;font-size:1.1em;line-height:1.3;">${b.title}</h3>
          <div style="margin-bottom:8px;color:var(--secondary);">by ${b.authors}</div>
          <div style="margin-bottom:8px;">Rating: ${b.rating}</div>
          ${b.categories.length ? `<div style="margin-bottom:12px;font-style:italic;color:var(--secondary);font-size:0.9em;">${b.categories.join(", ")}</div>` : ""}
          <div style="margin-bottom:12px;">
            <span style="color:var(--secondary)">Match Score: 
              <span id="score-${Math.random().toString(36).substr(2,9)}" class="score-display" onclick="showScoreBreakdown(this, ${JSON.stringify(b.scoreBreakdown).replace(/"/g, '&quot;')})">${(b.rankScore||0).toFixed(1)}/10</span>
            </span>
          </div>
        </div>
      </div>`;
    const save=Object.assign(document.createElement("button"),{textContent:"Save to My List",onclick:()=>saveBook(b)});
    c.appendChild(save);results.appendChild(c);
  });
}

/* ========== SAVED LIST (unchanged) ========== */
const getSaved=()=>JSON.parse(localStorage.getItem("savedBooks")||"[]");
const setSaved=l=>localStorage.setItem("savedBooks",JSON.stringify(l));
function saveBook(b){
  const l=getSaved();
  if(!l.some(x=>x.title===b.title&&x.authors===b.authors)){
    l.push(b);
    setSaved(l);
    showToast(`"${b.title}" saved to your list!`, 'success');
    hapticFeedback('success');
  } else {
    showToast(`"${b.title}" is already in your saved list.`, 'warning');
  }
  showSaved();
}
function showSaved(){
  const wrap=document.getElementById("savedList"),ctl=document.getElementById("savedControls");wrap.innerHTML="";ctl.innerHTML="";
  const list=getSaved();
  if(!list.length){wrap.innerHTML="<p>No saved books.</p>";return;}
  const sort=document.createElement("select");sort.id="savedSort";
  sort.innerHTML=`<option value="t-asc">Title A→Z</option><option value="t-desc">Title Z→A</option>
                  <option value="r-desc">Rating ↑</option><option value="r-asc">Rating ↓</option>`;
  sort.onchange=showSaved;ctl.append(sort,
    mkBtn("📄 Export CSV",exportCSV),mkBtn("📄 Export JSON",exportJSON),
    mkBtn("🗑️ Clear All",()=>{
      const count = getSaved().length;
      if(count === 0) {
        showToast("Your saved list is already empty.", 'info');
        return;
      }
      if(confirm(`Remove all ${count} books from your saved list?`)) {
        setSaved([]);
        showSaved();
        showToast(`Cleared ${count} books from saved list.`, 'success');
        hapticFeedback('medium');
      }
    }));
  const sorter={"t-asc":(a,b)=>a.title.localeCompare(b.title),"t-desc":(a,b)=>b.title.localeCompare(a.title),
                "r-desc":(a,b)=>(b.rating||0)-(a.rating||0),"r-asc":(a,b)=>(a.rating||0)-(b.rating||0)};
  list.sort(sorter[sort.value]);
  list.forEach((b,i)=>{
    const card=document.createElement("div");card.className="book-card";
    card.innerHTML=`
      <div class="book-display">
        ${b.thumb ? `<div class="book-image"><img src="${b.thumb}" alt="${b.title} cover"></div>` : ""}
        <div class="book-info">
          <h3 style="margin:0 0 8px 0;font-size:1.1em;line-height:1.3;">${b.title}</h3>
          <div style="margin-bottom:8px;color:var(--secondary);">by ${b.authors}</div>
          <div style="margin-bottom:12px;">Rating: ${b.rating}</div>
        </div>
      </div>`;
    const removeBtn = mkBtn("Remove",()=>{
      const bookTitle = list[i].title;
      list.splice(i,1);
      setSaved(list);
      showSaved();
      showToast(`"${bookTitle}" removed from saved list.`, 'info');
      hapticFeedback('medium');
    });
    removeBtn.className = "remove-btn";
    card.appendChild(removeBtn);
    wrap.appendChild(card);
  });
}
function exportCSV(){
  const l=getSaved();
  if(l.length === 0) {
    showToast("No books to export. Add some books to your saved list first.", 'warning');
    return;
  }
  const rows=[["Title","Authors","Rating","Categories"]];
  l.forEach(b=>rows.push([b.title,b.authors,b.rating,b.categories.join("|")]));
  download(rows,"saved_books.csv","text/csv");
  showToast(`Exported ${l.length} books to CSV file.`, 'success');
  hapticFeedback('success');
}

function exportJSON(){
  const l=getSaved();
  if(l.length === 0) {
    showToast("No books to export. Add some books to your saved list first.", 'warning');
    return;
  }
  download(JSON.stringify(l,null,2),"saved_books.json","application/json");
  showToast(`Exported ${l.length} books to JSON file.`, 'success');
  hapticFeedback('success');
}
function download(content,name,type){
  const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([content],{type}));a.download=name;a.click();URL.revokeObjectURL(a.href);}
const mkBtn=(txt,fn)=>{
  const btn = document.createElement("button");
  btn.textContent = txt;
  btn.onclick = enhancedClick(btn, fn, 'light');
  return btn;
};

/* ========== READING HISTORY WITH LIVE SEARCH ========== */
const searchBox=document.getElementById("bookSearch"),srDiv=document.getElementById("searchResults");
let searchTimer;
searchBox.addEventListener("input",()=>{clearTimeout(searchTimer);
  const q=searchBox.value.trim(); if(q.length<3){srDiv.style.display="none";return;}
  searchTimer=setTimeout(()=>fetchGB(q),400);
});
async function fetchGB(q){
  const url=`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}&maxResults=5&key=${API_KEY}`;
  const res=await fetch(url);const data=await res.json();
  const items=data.items||[];srDiv.innerHTML="";if(!items.length){srDiv.style.display="none";return;}
  items.forEach(item=>{
    const v=item.volumeInfo;const div=document.createElement("div");div.className="sr-item";
    div.innerHTML=`${v.imageLinks?`<img src='${v.imageLinks.thumbnail}'>`:""}
      <div><strong>${v.title}</strong><br>${(v.authors||[]).join(", ")}</div>`;
    div.onclick=()=>{const f=document.forms["historyForm"];f.title.value=v.title||"";f.author.value=(v.authors||[]).join(", ");f.genre.value=v.categories?.[0]||"";srDiv.style.display="none";searchBox.value="";};
    srDiv.appendChild(div);
  });
  srDiv.style.display="block";
}
document.addEventListener("click",e=>{if(!searchBox.contains(e.target)&&!srDiv.contains(e.target))srDiv.style.display="none";});

const getHistory=()=>JSON.parse(localStorage.getItem("readingHistory")||"[]");
const setHistory=l=>localStorage.setItem("readingHistory",JSON.stringify(l));
function addHistoryEntry(fd){
  const entry={title:fd.get("title"),author:fd.get("author")||"Unknown",rating:+fd.get("rating"),genre:fd.get("genre")||""};
  const list=getHistory();list.push(entry);setHistory(list);showHistory();document.getElementById("historyForm").reset();
  showToast(`"${entry.title}" added to reading history!`, 'success');
  hapticFeedback('success');
}
function showHistory(){
  const wrap=document.getElementById("historyList");wrap.innerHTML="";const list=getHistory();
  if(!list.length){wrap.innerHTML="<p>No entries yet.</p>";return;}
  list.forEach((b,i)=>{
    const card=document.createElement("div");card.className="book-card";
    const rating = Number(b.rating) || 0;
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.5 ? 1 : 0;
    const emptyStars = 5 - fullStars - halfStar;
    const starDisplay = "★".repeat(fullStars) + (halfStar ? "☆" : "") + "☆".repeat(emptyStars);
    
    card.innerHTML=`
      <div class="book-display">
        ${b.thumbnail ? 
          `<div class="book-image"><img src="${b.thumbnail}" style="cursor:pointer;border:2px solid var(--border);" onclick="editThumbnail(${i})" title="Click to edit thumbnail" alt="${b.title} cover"></div>` : 
          `<div class="book-image"><div style="height:80px;width:60px;background:var(--card);border:2px dashed var(--border);border-radius:var(--radius);display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:12px;text-align:center;color:var(--secondary);" onclick="editThumbnail(${i})" title="Click to add thumbnail">Add<br>Image</div></div>`
        }
        <div class="book-info">
          <h3 style="margin:0 0 8px 0;font-size:1.1em;line-height:1.3;">${b.title}</h3>
          <div style="margin-bottom:8px;color:var(--secondary);">by ${b.author}</div>
          <div style="margin-bottom:8px;">Rating: ${starDisplay} (${rating})</div>
          ${b.genre ? `<div style="margin-bottom:12px;font-style:italic;color:var(--secondary);font-size:0.9em;">${b.genre}</div>` : ""}
        </div>
      </div>`;
    const btnContainer = document.createElement("div");
    btnContainer.style.display = "flex";
    btnContainer.style.flexDirection = "column";
    btnContainer.style.gap = "8px";
    const editBtn = mkBtn("Edit", ()=>editHistoryEntry(i));
    editBtn.style.margin = "0";
    btnContainer.appendChild(editBtn);
    const removeBtn = mkBtn("Remove",()=>{
      const bookTitle = list[i].title;
      list.splice(i,1);
      setHistory(list);
      showHistory();
      showToast(`"${bookTitle}" removed from reading history.`, 'info');
      hapticFeedback('medium');
    });
    removeBtn.className = "remove-btn";
    removeBtn.style.margin = "0";
    btnContainer.appendChild(removeBtn);
    card.appendChild(btnContainer);
    wrap.appendChild(card);
  });
}

function editThumbnail(index) {
  const url = prompt("Enter image URL for thumbnail:");
  if (url) {
    const list = getHistory();
    list[index].thumbnail = url;
    setHistory(list);
    showHistory();
  }
}

function editHistoryEntry(index) {
  const list = getHistory();
  const entry = list[index];
  
  const newTitle = prompt("Edit title:", entry.title);
  if (newTitle === null) return; // User cancelled
  
  const newAuthor = prompt("Edit author:", entry.author);
  if (newAuthor === null) return;
  
  const newRating = prompt("Edit rating (0.5 to 5, with 0.5 increments):", entry.rating);
  if (newRating === null) return;
  
  const newGenre = prompt("Edit genres (comma-separated):", entry.genre);
  if (newGenre === null) return;
  
  // Validate rating
  const ratingNum = parseFloat(newRating);
  if (isNaN(ratingNum) || ratingNum < 0.5 || ratingNum > 5 || (ratingNum * 2) % 1 !== 0) {
    alert("Please enter a valid rating between 0.5 and 5 with 0.5 increments (e.g., 3.5, 4, 4.5)");
    return;
  }
  
  // Update entry
  list[index] = {
    ...entry,
    title: newTitle.trim(),
    author: newAuthor.trim(),
    rating: ratingNum,
    genre: newGenre.trim()
  };
  
  setHistory(list);
  showHistory();
}

/* ========== CSV IMPORT/EXPORT FUNCTIONS ========== */
async function importCSV(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const text = await file.text();
  const lines = text.split('\n').filter(line => line.trim());
  
  if (lines.length < 2) {
    alert("CSV file appears to be empty or invalid.");
    return;
  }
  
  const headers = lines[0].split(',').map(h => h.trim().toLowerCase().replace(/"/g, ''));
  const existingHistory = getHistory();
  let importedCount = 0;
  
  // Common header variations for different services
  const titleHeaders = ['title', 'book title', 'name'];
  const authorHeaders = ['author', 'authors', 'book author'];
  const ratingHeaders = ['rating', 'my rating', 'user rating', 'personal rating'];
  const genreHeaders = ['genre', 'genres', 'categories', 'subjects', 'bookshelves'];
  
  const titleIndex = headers.findIndex(h => titleHeaders.some(th => h.includes(th)));
  const authorIndex = headers.findIndex(h => authorHeaders.some(ah => h.includes(ah)));
  const ratingIndex = headers.findIndex(h => ratingHeaders.some(rh => h.includes(rh)));
  const genreIndex = headers.findIndex(h => genreHeaders.some(gh => h.includes(gh)));
  
  if (titleIndex === -1) {
    alert("Could not find a title column. Please ensure your CSV has a 'Title' column.");
    return;
  }
  
  for (let i = 1; i < lines.length; i++) {
    const cells = parseCSVLine(lines[i]);
    if (cells.length <= titleIndex) continue;
    
    const title = cells[titleIndex]?.trim();
    if (!title) continue;
    
    // Check if book already exists
    const existingBook = existingHistory.find(book => 
      book.title.toLowerCase() === title.toLowerCase()
    );
    
    if (existingBook) continue; // Skip duplicates
    
    const author = authorIndex >= 0 ? cells[authorIndex]?.trim() || "Unknown" : "Unknown";
    let rating = 3; // Default rating
    
    if (ratingIndex >= 0 && cells[ratingIndex]) {
      const ratingValue = parseFloat(cells[ratingIndex]);
      if (!isNaN(ratingValue) && ratingValue >= 0.5 && ratingValue <= 5) {
        // Round to nearest 0.5
        rating = Math.round(ratingValue * 2) / 2;
      }
    }
    
    const genre = genreIndex >= 0 ? cells[genreIndex]?.trim() || "" : "";
    
    const entry = {
      title,
      author,
      rating,
      genre
    };
    
    existingHistory.push(entry);
    importedCount++;
  }
  
  setHistory(existingHistory);
  showHistory();
  alert(`Successfully imported ${importedCount} books from CSV!`);
}

function parseCSVLine(line) {
  const cells = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      cells.push(current.trim().replace(/^"|"$/g, ''));
      current = '';
    } else {
      current += char;
    }
  }
  
  cells.push(current.trim().replace(/^"|"$/g, ''));
  return cells;
}

function exportHistory() {
  const history = getHistory();
  if (!history.length) {
    alert("No reading history to export.");
    return;
  }
  
  const headers = ['Title', 'Author', 'Rating', 'Genres'];
  const csvContent = [
    headers.join(','),
    ...history.map(book => [
      `"${book.title}"`,
      `"${book.author}"`,
      book.rating,
      `"${book.genre}"`
    ].join(','))
  ].join('\n');
  
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `bookwise-reading-history-${new Date().toISOString().split('T')[0]}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

function showCSVFormat() {
  const example = `Here are the CSV formats supported:

**Goodreads Export Format:**
Title,Author,My Rating,Bookshelves
"The Hobbit","J.R.R. Tolkien",5,"fantasy, adventure"
"1984","George Orwell",4.5,"dystopian, classics"

**Simple Format:**
Title,Author,Rating,Genre
"Dune","Frank Herbert",4.5,"Science Fiction"
"Pride and Prejudice","Jane Austen",4,"Romance, Classics"

**Required:**
- Title column (required)
- Author column (optional, defaults to "Unknown")
- Rating column (optional, defaults to 3.0)
- Genre/Categories column (optional)

**Notes:**
- Ratings will be rounded to nearest 0.5 (e.g., 4.3 becomes 4.5)
- Duplicate books (same title) will be skipped
- CSV should have headers in the first row`;
  
  alert(example);
}

function showRankingHelp() {
  const history = getHistory();
  const hasHistory = history.length > 0;
  
  let explanation = `📊 **How BookWise Ranking Works**

BookWise creates personalized match scores based on your reading history to help you find books you'll love!

`;

  if (hasHistory) {
    const likedCount = history.filter(book => Number(book.rating) >= 4).length;
    const dislikedCount = history.filter(book => Number(book.rating) <= 2).length;
    
    explanation += `**Your Reading Profile:**
📚 ${history.length} books in your history
👍 ${likedCount} books you loved (4-5 stars)
👎 ${dislikedCount} books you didn't enjoy (1-2 stars)

**Scoring System:**
🎯 **Genre Matching:**
  +2 points: Shares genre with books you rated 4-5 stars
  -2 points: Shares genre with books you rated 1-2 stars

👨‍💼 **Author Matching:**
  +1 point: Author you've rated highly before
  -1 point: Author you've rated poorly before

**Example:** If you loved "Dune" (Sci-Fi, 5 stars), then:
• "The Martian" (Sci-Fi) gets +2 points
• Another Frank Herbert book gets +3 points (+2 genre, +1 author)

**Higher scores = Better matches for YOU!**`;
  } else {
    explanation += `**Getting Started:**
🔄 Match scores are currently 0 because you haven't added any books to your reading history yet.

📖 **To get personalized recommendations:**
1. Go to "📚 Reading History" tab
2. Add books you've read with ratings
3. Import your Goodreads CSV for instant personalization!

**Once you have reading history:**
• Books matching your favorite genres get higher scores
• Books by authors you love get bonus points
• Books similar to ones you disliked get lower scores

The more books you add, the smarter the recommendations become! 🎯`;
  }
  
  alert(explanation);
}

function showScoreBreakdown(element, breakdown) {
  if (!breakdown) {
    alert("Score breakdown not available for this book.");
    return;
  }
  
  let explanation = `📊 **Score Breakdown** (Out of 10)\n\n`;
  
  if (breakdown.explanation) {
    explanation += breakdown.explanation;
  } else {
    explanation += `**Your Reading History Analysis:**\n\n`;
    
    if (breakdown.genreDetails && breakdown.genreDetails.length > 0) {
      explanation += `🎭 **Genre Preferences:**\n`;
      breakdown.genreDetails.forEach(detail => {
        explanation += `• ${detail}\n`;
      });
      explanation += `\n`;
    }
    
    if (breakdown.authorDetails && breakdown.authorDetails.length > 0) {
      explanation += `✍️ **Author Experience:**\n`;
      breakdown.authorDetails.forEach(detail => {
        explanation += `• ${detail}\n`;
      });
      explanation += `\n`;
    }
    
    if (breakdown.keywordDetails && breakdown.keywordDetails.length > 0) {
      explanation += `🔍 **Thematic Matching:**\n`;
      breakdown.keywordDetails.forEach(detail => {
        explanation += `• ${detail}\n`;
      });
      explanation += `\n`;
    }
    
    if ((!breakdown.genreDetails || breakdown.genreDetails.length === 0) && 
        (!breakdown.authorDetails || breakdown.authorDetails.length === 0) &&
        (!breakdown.keywordDetails || breakdown.keywordDetails.length === 0)) {
      explanation += `⚪ No specific genre, author, or thematic matches found in your reading history\n\n`;
    }
    
    explanation += `**Score Components:**\n`;
    
    if (breakdown.preferenceScore !== 0) {
      const prefText = breakdown.preferenceScore > 0 ? "positive" : "negative";
      explanation += `📈 Personal Preferences: ${breakdown.preferenceScore > 0 ? '+' : ''}${breakdown.preferenceScore.toFixed(1)} pts (${prefText} based on similar books you've read)\n`;
    }
    
    if (breakdown.offlineBonus > 0) {
      explanation += `📚 Offline Recommendations: +${breakdown.offlineBonus.toFixed(1)} pts (related books in database)\n`;
    }
    
    explanation += `\n**Final Calculation:**\n`;
    explanation += `Raw Score: ${breakdown.total.toFixed(2)}\n`;
    explanation += `Scaled Score: ${breakdown.scaledTotal.toFixed(1)}/10\n\n`;
    explanation += `💡 **How it works:** Instead of just looking at genres broadly, BookWise analyzes your ratings for individual books within each genre and author to give you truly personalized recommendations!`;
  }
  
  alert(explanation);
}

/* ---------- BOOK SIMILARITY FUNCTION ---------- */
function bookSimilarity(bookA, bookB) {
  let score = 0;
  // Title similarity
  if (bookA.title && bookB.title) {
    const a = bookA.title.toLowerCase(), b = bookB.title.toLowerCase();
    if (a === b) score += 3;
    else if (a.includes(b) || b.includes(a)) score += 2;
  }
  // Author similarity
  if (bookA.authors && bookB.author) {
    const a = bookA.authors.toLowerCase(), b = bookB.author.toLowerCase();
    if (a === b) score += 2;
    else if (a.includes(b) || b.includes(a)) score += 1;
  }
  // Genre similarity
  if (bookA.categories && bookB.genre) {
    if (bookA.categories.some(cat => cat.toLowerCase() === bookB.genre.toLowerCase())) score += 1;
  }
  return score;
}

function rankScannedBooks(scannedBooks) {
  const history = getHistory();
  
  if (!history.length) {
    return scannedBooks.map(book => ({...book, rankScore: 0}));
  }
  
  // Categorize books by rating for preference analysis
  const likedBooks = history.filter(book => Number(book.rating) >= 4);
  const dislikedBooks = history.filter(book => Number(book.rating) <= 2);
  
  // Extract genres and authors for comparison
  const likedGenres = new Set();
  const dislikedGenres = new Set();
  const likedAuthors = new Set();
  const dislikedAuthors = new Set();
  
  likedBooks.forEach(book => {
    if (book.genre) {
      book.genre.split(',').forEach(genre => 
        likedGenres.add(genre.trim().toLowerCase())
      );
    }
    if (book.author) {
      likedAuthors.add(book.author.trim().toLowerCase());
    }
  });
  
  dislikedBooks.forEach(book => {
    if (book.genre) {
      book.genre.split(',').forEach(genre => 
        dislikedGenres.add(genre.trim().toLowerCase())
      );
    }
    if (book.author) {
      dislikedAuthors.add(book.author.trim().toLowerCase());
    }
  });
  
  return scannedBooks.map(book => {
    let rankScore = 0;
    
    // Advanced preference scoring - considers individual books within genres
    const preferenceScore = calculateAdvancedPreferenceScore(book, history);
    rankScore += preferenceScore;
    
    // Offline dataset enhancement scoring
    const offlineBonus = getOfflineRecommendationBonus(book, history);
    rankScore += offlineBonus;
    
    // Scale score to be out of 10 (approximate max would be around 5-6, so multiply by ~1.7)
    const scaledScore = Math.min(Math.max(rankScore * 1.7, 0), 10);
    
    // Store breakdown for tooltip
    const scoreBreakdown = calculateScoreBreakdown(book, history, rankScore, offlineBonus, preferenceScore);
    
    return {...book, rankScore: scaledScore, scoreBreakdown};
  });
}

/* ========== ADVANCED PREFERENCE SCORING ========== */
function calculateAdvancedPreferenceScore(scannedBook, userHistory) {
  if (!userHistory.length || !scannedBook.categories) return 0;
  
  let totalScore = 0;
  const bookCategories = scannedBook.categories.map(cat => cat.toLowerCase());
  const bookAuthors = scannedBook.authors ? scannedBook.authors.toLowerCase() : '';
  
  // For each category of the scanned book, calculate a nuanced score
  bookCategories.forEach(scannedCategory => {
    let categoryScore = 0;
    let categoryVotes = 0;
    
    // Extract specific tags/themes from the scanned category
    const scannedTags = extractTags(scannedCategory);
    
    // Look at all books in user's history that share this genre OR similar tags
    userHistory.forEach(historyBook => {
      const historyGenres = historyBook.genre ? 
        historyBook.genre.split(',').map(g => g.trim().toLowerCase()) : [];
      const historyAuthor = historyBook.author ? historyBook.author.toLowerCase() : '';
      const rating = Number(historyBook.rating) || 3;
      
      // Check for both genre match AND tag overlap
      const genreMatch = historyGenres.some(hg => 
        hg.includes(scannedCategory) || scannedCategory.includes(hg)
      );
      
      const tagOverlap = calculateTagOverlap(scannedTags, historyGenres);
      
      if (genreMatch || tagOverlap.score > 0) {
        categoryVotes++;
        
        // Weight the vote based on rating, similarity, and tag overlap
        let voteWeight = 1;
        
        // Stronger weight if it's the same author
        if (bookAuthors && historyAuthor && 
            (bookAuthors.includes(historyAuthor) || historyAuthor.includes(bookAuthors))) {
          voteWeight = 2;
        }
        
        // Boost weight for strong tag overlap
        if (tagOverlap.score > 0.5) {
          voteWeight *= (1 + tagOverlap.score);
        }
        
        // Convert rating to preference score (-2 to +2 scale)
        let preferenceValue = 0;
        if (rating >= 4.5) preferenceValue = 2;
        else if (rating >= 3.5) preferenceValue = 1;
        else if (rating >= 2.5) preferenceValue = 0;
        else if (rating >= 1.5) preferenceValue = -1;
        else preferenceValue = -2;
        
        categoryScore += preferenceValue * voteWeight;
      }
    });
    
    // Calculate weighted average for this category
    if (categoryVotes > 0) {
      const avgCategoryScore = categoryScore / categoryVotes;
      totalScore += avgCategoryScore;
    }
  });
  
  // Author scoring (independent of genre)
  if (bookAuthors) {
    let authorScore = 0;
    let authorVotes = 0;
    let totalAuthorRating = 0;
    
    // Find ALL books by this author in user's history
    userHistory.forEach(historyBook => {
      const historyAuthor = historyBook.author ? historyBook.author.toLowerCase() : '';
      
      if (historyAuthor && 
          (bookAuthors.includes(historyAuthor) || historyAuthor.includes(bookAuthors))) {
        const rating = Number(historyBook.rating) || 3;
        authorVotes++;
        totalAuthorRating += rating;
      }
    });
    
    // Calculate average rating for this author and convert to preference score
    if (authorVotes > 0) {
      const avgAuthorRating = totalAuthorRating / authorVotes;
      
      // Convert average rating to preference score (-2 to +2 scale)
      let authorPreference = 0;
      if (avgAuthorRating >= 4.5) authorPreference = 2;
      else if (avgAuthorRating >= 3.5) authorPreference = 1;
      else if (avgAuthorRating >= 2.5) authorPreference = 0;
      else if (avgAuthorRating >= 1.5) authorPreference = -1;
      else authorPreference = -2;
      
      // Weight the score by confidence (more books = more reliable)
      const confidenceWeight = Math.min(authorVotes / 3, 1); // Caps at 1 for 3+ books
      totalScore += authorPreference * confidenceWeight;
    }
  }
  
  // Keyword-based description matching for thematic similarity
  if (scannedBook.description || scannedBook.subtitle) {
    const scannedDescription = (scannedBook.description || '') + ' ' + (scannedBook.subtitle || '');
    const scannedKeywords = extractKeywords(scannedDescription);
    
    if (scannedKeywords.length > 0) {
      let keywordScore = 0;
      let keywordVotes = 0;
      
      // Compare with highly-rated books in user's history
      userHistory.forEach(historyBook => {
        const rating = Number(historyBook.rating) || 3;
        
        // Only consider books rated 3.5+ for positive keyword associations
        if (rating >= 3.5 && historyBook.title) {
          // Use title + genre as description proxy (since we don't have full descriptions)
          const historyDescription = historyBook.title + ' ' + (historyBook.genre || '');
          const historyKeywords = extractKeywords(historyDescription);
          
          const keywordOverlap = calculateKeywordOverlap(scannedKeywords, historyKeywords);
          
          if (keywordOverlap.score > 0) {
            keywordVotes++;
            
            // Convert rating to preference score
            let preferenceValue = 0;
            if (rating >= 4.5) preferenceValue = 1.5;
            else if (rating >= 4.0) preferenceValue = 1.0;
            else preferenceValue = 0.5;
            
            // Weight by keyword overlap strength
            keywordScore += preferenceValue * keywordOverlap.score;
          }
        }
      });
      
      // Add keyword score with diminishing returns to prevent overwhelming other factors
      if (keywordVotes > 0) {
        const avgKeywordScore = keywordScore / keywordVotes;
        totalScore += Math.min(avgKeywordScore, 1); // Cap keyword contribution at +1
      }
    }
  }
  
  return totalScore;
}

/* ========== TAG-BASED PREFERENCE FUNCTIONS ========== */
function extractTags(genreText) {
  const text = genreText.toLowerCase();
  const tags = [];
  
  // Define comprehensive tag patterns for specific themes/subgenres
  const tagPatterns = {
    // Horror subgenres
    'gothic': ['gothic', 'dark romanticism', 'victorian horror'],
    'psychological': ['psychological', 'mind', 'mental', 'psycho'],
    'supernatural': ['supernatural', 'paranormal', 'ghost', 'haunted', 'occult'],
    'cosmic': ['cosmic', 'lovecraftian', 'eldrich', 'cosmic horror'],
    'body horror': ['body horror', 'visceral', 'grotesque', 'medical horror'],
    
    // Fantasy subgenres
    'medieval': ['medieval', 'middle ages', 'feudal', 'knights', 'castles'],
    'urban fantasy': ['urban', 'modern fantasy', 'contemporary fantasy'],
    'high fantasy': ['high fantasy', 'epic fantasy', 'sword and sorcery'],
    'dark fantasy': ['dark fantasy', 'grimdark'],
    'fairy tale': ['fairy tale', 'folklore', 'myth', 'legend'],
    
    // Sci-Fi subgenres
    'dystopian': ['dystopian', 'post-apocalyptic', 'totalitarian'],
    'cyberpunk': ['cyberpunk', 'cyber', 'hacker', 'virtual reality'],
    'space opera': ['space opera', 'galactic', 'interstellar'],
    'hard sci-fi': ['hard science', 'scientific', 'technical'],
    'time travel': ['time travel', 'temporal', 'chronological'],
    
    // Mystery/Thriller subgenres
    'noir': ['noir', 'hard-boiled', 'detective'],
    'cozy mystery': ['cozy', 'amateur detective', 'village mystery'],
    'spy thriller': ['spy', 'espionage', 'intelligence'],
    'legal thriller': ['legal', 'courtroom', 'lawyer'],
    'medical thriller': ['medical', 'hospital', 'doctor'],
    
    // Romance subgenres
    'historical romance': ['historical', 'period', 'regency', 'victorian'],
    'paranormal romance': ['paranormal', 'vampire', 'werewolf', 'shapeshifter'],
    'contemporary romance': ['contemporary', 'modern'],
    'romantic suspense': ['suspense', 'danger', 'thriller'],
    
    // Literary themes
    'coming of age': ['coming of age', 'bildungsroman', 'young adult', 'adolescence'],
    'family saga': ['family', 'generational', 'multi-generational'],
    'war': ['war', 'military', 'battle', 'combat', 'wwii', 'vietnam'],
    'social commentary': ['social', 'political', 'society', 'class'],
    'existential': ['existential', 'philosophical', 'meaning of life'],
    
    // Settings/Atmospheres
    'small town': ['small town', 'rural', 'village', 'countryside'],
    'big city': ['city', 'urban', 'metropolitan', 'new york', 'london'],
    'isolated': ['isolated', 'remote', 'cabin', 'island', 'wilderness'],
    'academic': ['university', 'college', 'academic', 'professor', 'school'],
    'workplace': ['office', 'corporate', 'business', 'workplace']
  };
  
  // Check for tag matches
  Object.keys(tagPatterns).forEach(tag => {
    const patterns = tagPatterns[tag];
    if (patterns.some(pattern => text.includes(pattern))) {
      tags.push(tag);
    }
  });
  
  // Also include the original genre as a tag (normalized)
  tags.push(text.replace(/[^a-z\s]/g, '').trim());
  
  return [...new Set(tags)]; // Remove duplicates
}

function calculateTagOverlap(scannedTags, historyGenres) {
  if (!scannedTags.length || !historyGenres.length) {
    return { score: 0, matches: [] };
  }
  
  const matches = [];
  const historyTags = [];
  
  // Extract tags from all history genres
  historyGenres.forEach(genre => {
    const tags = extractTags(genre);
    historyTags.push(...tags);
  });
  
  // Find overlapping tags
  scannedTags.forEach(scannedTag => {
    historyTags.forEach(historyTag => {
      if (scannedTag === historyTag || 
          scannedTag.includes(historyTag) || 
          historyTag.includes(scannedTag)) {
        matches.push({ scanned: scannedTag, history: historyTag });
      }
    });
  });
  
  // Calculate overlap score (0 to 1)
  const uniqueMatches = [...new Set(matches.map(m => m.scanned))];
  const overlapScore = uniqueMatches.length / Math.max(scannedTags.length, 1);
  
  return {
    score: overlapScore,
    matches: uniqueMatches
  };
}

// Extract meaningful keywords from book descriptions
function extractKeywords(description) {
  if (!description) return [];
  
  // Common stop words to filter out
  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 
    'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 
    'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must',
    'this', 'that', 'these', 'those', 'his', 'her', 'their', 'he', 'she', 'it', 'they',
    'when', 'where', 'why', 'how', 'what', 'who', 'which', 'can', 'one', 'two', 'new',
    'old', 'first', 'last', 'good', 'great', 'best', 'book', 'story', 'novel', 'author'
  ]);
  
  // Meaningful keywords patterns (nouns, adjectives, thematic terms)
  const meaningfulPatterns = [
    // Settings & Places
    /\b(castle|palace|kingdom|village|city|forest|mountain|desert|ocean|island|space|planet|ship|station)\b/gi,
    /\b(medieval|victorian|modern|ancient|future|dystopian|utopian|magical|supernatural)\b/gi,
    /\b(academy|school|university|hospital|prison|mansion|cottage|tower|temple|church)\b/gi,
    
    // Characters & Relationships  
    /\b(prince|princess|king|queen|knight|warrior|wizard|witch|vampire|werewolf|dragon|demon|angel)\b/gi,
    /\b(detective|spy|assassin|thief|pirate|captain|doctor|scientist|professor|student)\b/gi,
    /\b(romance|love|marriage|friendship|family|betrayal|revenge|sacrifice|loyalty|honor)\b/gi,
    /\b(enemies|lovers|rivals|allies|mentor|apprentice|siblings|parents|children)\b/gi,
    
    // Themes & Concepts
    /\b(magic|power|curse|prophecy|destiny|fate|immortal|mortal|death|life|soul|spirit)\b/gi,
    /\b(war|battle|quest|journey|adventure|escape|survival|rescue|discovery|mystery)\b/gi,
    /\b(secret|hidden|forbidden|ancient|lost|forgotten|chosen|special|unique|rare)\b/gi,
    /\b(dark|light|shadow|blood|fire|ice|storm|night|dawn|time|memory|dream)\b/gi,
    
    // Emotions & Tone
    /\b(dangerous|deadly|haunting|beautiful|terrifying|mysterious|enchanting|forbidden)\b/gi,
    /\b(epic|intimate|heartbreaking|thrilling|suspenseful|romantic|comedic|tragic)\b/gi,
    /\b(complex|simple|twisted|pure|corrupt|innocent|wise|foolish|brave|cowardly)\b/gi,
    
    // Plot Elements
    /\b(conspiracy|investigation|heist|tournament|competition|ritual|ceremony|trial)\b/gi,
    /\b(rebellion|revolution|invasion|siege|alliance|treaty|betrayal|murder|theft)\b/gi,
    /\b(transformation|awakening|revelation|confrontation|sacrifice|redemption)\b/gi
  ];
  
  const keywords = new Set();
  
  // Extract pattern-based keywords
  meaningfulPatterns.forEach(pattern => {
    const matches = description.match(pattern);
    if (matches) {
      matches.forEach(match => keywords.add(match.toLowerCase().trim()));
    }
  });
  
  // Extract important adjectives and nouns (fallback for other meaningful words)
  const words = description.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length >= 4 && !stopWords.has(word))
    .filter(word => /^[a-z]+$/.test(word)); // Only alphabetic words
  
  // Add high-value words that might not match patterns
  words.forEach(word => {
    // Add words that appear in genre-defining contexts or are descriptive
    if (word.length >= 5 || 
        ['dark', 'lost', 'dead', 'wild', 'cold', 'deep', 'true', 'real'].includes(word)) {
      keywords.add(word);
    }
  });
  
  return Array.from(keywords).slice(0, 20); // Limit to top 20 keywords
}

// Calculate keyword overlap between descriptions
function calculateKeywordOverlap(keywords1, keywords2) {
  if (!keywords1.length || !keywords2.length) return { score: 0, matches: [] };
  
  const matches = keywords1.filter(keyword => keywords2.includes(keyword));
  const score = matches.length / Math.max(keywords1.length, keywords2.length, 1);
  
  // Bonus for multiple shared keywords (indicates strong thematic similarity)
  let bonusMultiplier = 1;
  if (matches.length >= 5) bonusMultiplier = 1.5;
  else if (matches.length >= 3) bonusMultiplier = 1.3;
  else if (matches.length >= 2) bonusMultiplier = 1.1;
  
  return { 
    score: Math.min(score * bonusMultiplier, 1), 
    matches: matches.slice(0, 5) // Show top 5 matches
  };
}

/* ========== OFFLINE RECOMMENDATION FUNCTIONS ========== */
function getOfflineRecommendationBonus(scannedBook, userHistory) {
  if (!bookDataset.length) return 0;
  
  let bonus = 0;
  const userReadTitles = new Set(userHistory.map(book => book.title.toLowerCase()));
  
  // Find matches in dataset by title or author
  const matches = findDatasetMatches(scannedBook);
  
  matches.forEach(match => {
    // If this exact book is in our dataset and has related books
    if (match.related && match.related.length > 0) {
      // Check if any related books match user's reading preferences
      match.related.forEach(relatedTitle => {
        const relatedBook = bookDataset.find(book => 
          book.title.toLowerCase() === relatedTitle.toLowerCase()
        );
        
        if (relatedBook && !userReadTitles.has(relatedBook.title.toLowerCase())) {
          // Bonus for unread related books
          bonus += 0.5;
          
          // Additional bonus if related book matches user's preferred genres/authors
          const userLikedBooks = userHistory.filter(book => Number(book.rating) >= 4);
          userLikedBooks.forEach(likedBook => {
            // Genre similarity bonus
            if (relatedBook.genres && likedBook.genre) {
              const likedGenres = likedBook.genre.split(',').map(g => g.trim().toLowerCase());
              const relatedGenres = relatedBook.genres.map(g => g.toLowerCase());
              
              if (likedGenres.some(lg => relatedGenres.some(rg => 
                rg.includes(lg) || lg.includes(rg)))) {
                bonus += 0.3;
              }
            }
            
            // Author similarity bonus
            if (relatedBook.authors && likedBook.author) {
              const relatedAuthors = relatedBook.authors.map(a => a.toLowerCase());
              const likedAuthor = likedBook.author.toLowerCase();
              
              if (relatedAuthors.some(ra => 
                ra.includes(likedAuthor) || likedAuthor.includes(ra))) {
                bonus += 0.5;
              }
            }
          });
        }
      });
    }
  });
  
  return Math.min(bonus, 3); // Cap the offline bonus at +3 points
}

function calculateScoreBreakdown(book, userHistory, rawScore, offlineBonus, preferenceScore) {
  const breakdown = {
    preferenceScore: preferenceScore || 0,
    offlineBonus: offlineBonus || 0,
    total: rawScore,
    scaledTotal: Math.min(Math.max(rawScore * 1.7, 0), 10)
  };
  
  if (!userHistory.length) {
    return {
      ...breakdown,
      explanation: "No reading history available for personalized scoring."
    };
  }
  
  // Calculate detailed preference breakdown
  let genreDetails = [];
  let authorDetails = [];
  
  if (book.categories) {
    book.categories.forEach(category => {
      const categoryLower = category.toLowerCase();
      const scannedTags = extractTags(category);
      
      const matchingBooks = userHistory.filter(histBook => {
        const histGenres = histBook.genre ? 
          histBook.genre.split(',').map(g => g.trim().toLowerCase()) : [];
        
        // Check both genre match and tag overlap
        const genreMatch = histGenres.some(hg => 
          hg.includes(categoryLower) || categoryLower.includes(hg)
        );
        const tagOverlap = calculateTagOverlap(scannedTags, histGenres);
        
        return genreMatch || tagOverlap.score > 0;
      });
      
      if (matchingBooks.length > 0) {
        const avgRating = matchingBooks.reduce((sum, book) => 
          sum + (Number(book.rating) || 3), 0) / matchingBooks.length;
        const ratingText = avgRating >= 4 ? "loved" : 
                          avgRating >= 3.5 ? "liked" : 
                          avgRating >= 2.5 ? "mixed feelings about" : "disliked";
        
        // Show specific tags that matched
        const tagMatches = [];
        matchingBooks.forEach(histBook => {
          const histGenres = histBook.genre ? 
            histBook.genre.split(',').map(g => g.trim().toLowerCase()) : [];
          const overlap = calculateTagOverlap(scannedTags, histGenres);
          if (overlap.matches.length > 0) {
            tagMatches.push(...overlap.matches);
          }
        });
        const uniqueTagMatches = [...new Set(tagMatches)];
        
        let detail = `${category}: You ${ratingText} ${matchingBooks.length} similar book${matchingBooks.length > 1 ? 's' : ''} (avg: ${avgRating.toFixed(1)}★)`;
        
        if (uniqueTagMatches.length > 0) {
          detail += ` - matched themes: ${uniqueTagMatches.slice(0, 3).join(', ')}${uniqueTagMatches.length > 3 ? '...' : ''}`;
        }
        
        genreDetails.push(detail);
      }
    });
  }
  
  if (book.authors) {
    const bookAuthors = book.authors.toLowerCase();
    const matchingBooks = userHistory.filter(histBook => {
      const histAuthor = histBook.author ? histBook.author.toLowerCase() : '';
      return histAuthor && (bookAuthors.includes(histAuthor) || histAuthor.includes(bookAuthors));
    });
    
    if (matchingBooks.length > 0) {
      const avgRating = matchingBooks.reduce((sum, book) => 
        sum + (Number(book.rating) || 3), 0) / matchingBooks.length;
      const ratingText = avgRating >= 4 ? "loved" : 
                        avgRating >= 3.5 ? "liked" : 
                        avgRating >= 2.5 ? "had mixed feelings about" : "disliked";
      
      const confidenceText = matchingBooks.length >= 3 ? "high confidence" : 
                           matchingBooks.length === 2 ? "moderate confidence" : "low confidence";
      
      authorDetails.push(`You ${ratingText} ${matchingBooks.length} book${matchingBooks.length > 1 ? 's' : ''} by this author (avg: ${avgRating.toFixed(1)}★, ${confidenceText})`);
    }
  }
  
  // Keyword-based thematic matching details
  const keywordDetails = [];
  if (book.description || book.subtitle) {
    const scannedDescription = (book.description || '') + ' ' + (book.subtitle || '');
    const scannedKeywords = extractKeywords(scannedDescription);
    
    if (scannedKeywords.length > 0) {
      // Find books with keyword matches
      const keywordMatches = [];
      userHistory.forEach(histBook => {
        const rating = Number(histBook.rating) || 3;
        
        if (rating >= 3.5 && histBook.title) {
          const historyDescription = histBook.title + ' ' + (histBook.genre || '');
          const historyKeywords = extractKeywords(historyDescription);
          const overlap = calculateKeywordOverlap(scannedKeywords, historyKeywords);
          
          if (overlap.score > 0 && overlap.matches.length > 0) {
            keywordMatches.push({
              book: histBook.title,
              rating: rating,
              matches: overlap.matches
            });
          }
        }
      });
      
      if (keywordMatches.length > 0) {
        const avgRating = keywordMatches.reduce((sum, match) => 
          sum + match.rating, 0) / keywordMatches.length;
        
        const allMatches = keywordMatches.reduce((acc, match) => 
          acc.concat(match.matches), []);
        const uniqueMatches = [...new Set(allMatches)];
        
        let detail = `Thematic similarity: Found ${keywordMatches.length} book${keywordMatches.length > 1 ? 's' : ''} with shared themes (avg: ${avgRating.toFixed(1)}★)`;
        detail += ` - keywords: ${uniqueMatches.slice(0, 4).join(', ')}${uniqueMatches.length > 4 ? '...' : ''}`;
        
        keywordDetails.push(detail);
      }
    }
  }
  
  return {
    ...breakdown,
    genreDetails,
    authorDetails,
    keywordDetails
  };
}

function findDatasetMatches(scannedBook) {
  if (!bookDataset.length) return [];
  
  const matches = [];
  const scannedTitle = scannedBook.title ? scannedBook.title.toLowerCase() : '';
  const scannedAuthors = scannedBook.authors ? scannedBook.authors.toLowerCase() : '';
  
  bookDataset.forEach(book => {
    let isMatch = false;
    
    // Title matching (exact or partial)
    if (book.title && scannedTitle) {
      const datasetTitle = book.title.toLowerCase();
      if (datasetTitle.includes(scannedTitle) || scannedTitle.includes(datasetTitle)) {
        isMatch = true;
      }
    }
    
    // Author matching
    if (!isMatch && book.authors && scannedAuthors) {
      book.authors.forEach(author => {
        const authorLower = author.toLowerCase();
        if (authorLower.includes(scannedAuthors) || scannedAuthors.includes(authorLower)) {
          isMatch = true;
        }
      });
    }
    
    if (isMatch) {
      matches.push(book);
    }
  });
  
  return matches;
}

/* ========== INIT ========== */
let bookDataset = [];
// Load offline book dataset for enhanced recommendations
async function loadBookDataset() {
  try {
    const response = await fetch('./bookwise_recommendations_dataset.json');
    bookDataset = await response.json();
    console.log(`Loaded ${bookDataset.length} books for offline recommendations`);
  } catch (error) {
    console.warn('Could not load offline book dataset:', error);
  }
}

showSaved();
showHistory();
loadBookDataset();
</script>
</body>
</html>
