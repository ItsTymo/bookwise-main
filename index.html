<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BookWise</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="manifest" href="manifest.webmanifest">
<style>
  :root{--bg:#fff;--text:#111;--card:#f6f6f6;--accent:#0074d9}
  [data-theme="dark"]{--bg:#121212;--text:#f5f5f5;--card:#1e1e1e;--accent:#00baff}
  body{margin:0;padding:20px;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);transition:.3s}
  h1,h2{margin-top:0}
  button,select,input[type=file]{margin:6px 4px;padding:6px 10px;font-size:1rem}
  .book-card{border:1px solid #ccc;border-color:var(--card);background:var(--card);padding:10px;margin-bottom:10px;max-width:420px}
  .flex{display:flex;align-items:center;margin-bottom:6px}
  .flex input{flex:1}
  /* --- Tabs --- */
  #tabBar{display:flex;gap:10px;margin-bottom:15px;flex-wrap:wrap}
  .tab-btn{background:var(--card);border:1px solid var(--accent);border-radius:5px;cursor:pointer}
  .tab-btn.active{background:var(--accent);color:#fff}
  .tab{display:none}
  .tab.active{display:block}

  /* History search dropdown */
  #searchResults{border:1px solid #ccc;max-height:250px;overflow-y:auto;background:#fff;
                 position:absolute;left:0;right:0;z-index:10;display:none}
  .sr-item{display:flex;gap:8px;padding:6px;cursor:pointer;border-bottom:1px solid #ddd}
  .sr-item img{height:60px;width:auto}
  .sr-item:last-child{border-bottom:none}
</style>
</head>
<body>
<h1>BookWise</h1>

<!-- TAB BUTTONS -->
<div id="tabBar">
  <button class="tab-btn" data-tab="scannerTab">📷 Scanner</button>
  <button class="tab-btn" data-tab="savedTab">⭐ Saved List</button>
  <button class="tab-btn" data-tab="historyTab">📚 Reading History</button>
  <button id="themeToggle" style="margin-left:auto">🌙 Dark Mode</button>
</div>

<!-- ============ SCANNER TAB ============ -->
<div id="scannerTab" class="tab active">
  <div id="topBar" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px">
    <!-- Hidden inputs -->
    <input type="file" id="imageInput" accept="image/*" style="display:none">
    <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">
    <!-- Visible buttons -->
    <button id="uploadBtn">📁 Upload Photo</button>
    <button id="cameraBtn">📷 Take Photo</button>
  </div>

  <p id="statusMsg" style="color:gray"></p>
  <pre id="output"></pre>
  <div id="results"></div>
</div>

<!-- ============ SAVED LIST TAB ============ -->
<div id="savedTab" class="tab">
  <h2>My Saved List</h2>
  <div id="savedControls"></div>
  <div id="savedList"></div>
</div>

<!-- ============ READING HISTORY TAB ============ -->
<div id="historyTab" class="tab">
  <h2>Books I've Read</h2>

  <!-- Import Section -->
  <div style="max-width:420px;margin-bottom:15px;padding:10px;background:var(--card);border-radius:5px;">
    <h3 style="margin-top:0;">Import from CSV</h3>
    <p style="margin:5px 0;font-size:0.9em;color:var(--text);">
      Import your reading history from Goodreads or other services. 
      <a href="#" onclick="showCSVFormat()" style="color:var(--accent);">See expected format</a>
    </p>
    <input type="file" id="csvInput" accept=".csv,.txt" style="display:none">
    <button id="importBtn" style="margin-right:10px;">📁 Import CSV File</button>
    <button id="exportHistoryBtn">📄 Export My History</button>
  </div>

  <!-- Live Search Input -->
  <div style="max-width:420px;margin-bottom:10px;position:relative">
    <label for="bookSearch">Search by Title:</label>
    <input type="text" id="bookSearch" placeholder="e.g. The Hobbit" style="width:100%">
    <div id="searchResults"></div>
  </div>

  <!-- Manual entry / auto‑fill form -->
  <form id="historyForm" class="flex" style="flex-direction:column;max-width:420px">
    <input type="text" name="title" placeholder="Title" required>
    <input type="text" name="author" placeholder="Author">
    <label>Rating:
      <select name="rating">
        <option value="5">★★★★★ 5</option>
        <option value="4.5">★★★★☆ 4.5</option>
        <option value="4">★★★★☆ 4</option>
        <option value="3.5">★★★☆☆ 3.5</option>
        <option value="3">★★★☆☆ 3</option>
        <option value="2.5">★★☆☆☆ 2.5</option>
        <option value="2">★★☆☆☆ 2</option>
        <option value="1.5">★☆☆☆☆ 1.5</option>
        <option value="1">★☆☆☆☆ 1</option>
        <option value="0.5">☆☆☆☆☆ 0.5</option>
      </select>
    </label>
    <input type="text" name="genre" placeholder="Genres (comma-separated, e.g., Fiction, Mystery)">
    <button>Add Book</button>
  </form>

  <div id="historyList" style="margin-top:15px"></div>
</div>

<!-- *****  REPLACE WITH YOUR REAL KEY  ***** -->
<script>const API_KEY="AIzaSyAVbYZOoKpBB3IQhluruE1jQsjJ0SZdZPw";</script>

<script>
/* ========== THEME TOGGLE ========== */
const prefersDark=matchMedia("(prefers-color-scheme:dark)").matches;
document.documentElement.dataset.theme=
  localStorage.getItem("theme")|| (prefersDark?"dark":"light");
const themeBtn=document.getElementById("themeToggle");
const updateThemeButton=()=>
  themeBtn.textContent=document.documentElement.dataset.theme==="dark"?"☀️ Light Mode":"🌙 Dark Mode";
updateThemeButton();
themeBtn.onclick=()=>{
  document.documentElement.dataset.theme=
    document.documentElement.dataset.theme==="dark"?"light":"dark";
  localStorage.setItem("theme",document.documentElement.dataset.theme);
  updateThemeButton();
};

/* ========== TAB SWITCHING ========== */
document.querySelectorAll(".tab-btn").forEach(btn=>{
  btn.onclick=()=>{
    document.querySelectorAll(".tab-btn").forEach(b=>b.classList.remove("active"));
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    btn.classList.add("active");
    document.getElementById(btn.dataset.tab).classList.add("active");
  };
});

/* ========== BUTTON TRIGGERS (Scanner) ========== */
document.getElementById("uploadBtn").onclick=()=>document.getElementById("imageInput").click();
document.getElementById("cameraBtn").onclick=()=>document.getElementById("cameraInput").click();
document.getElementById("importBtn").onclick=()=>document.getElementById("csvInput").click();
document.getElementById("exportHistoryBtn").onclick=exportHistory;
["imageInput","cameraInput"].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener("change",e=>{processImage(e).then(()=>el.value="");});
});
document.getElementById("csvInput").addEventListener("change",e=>{importCSV(e).then(()=>e.target.value="");});

/* ========== OCR TEXT PROCESSING FUNCTIONS ========== */

// Clean and filter OCR lines to remove noise
function cleanOCRLines(rawLines) {
  const debugLog = { discarded: [], cleaned: [] };
  
  // Common stopwords and noise patterns
  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
    'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',
    'will', 'would', 'could', 'should', 'may', 'might', 'must', 'this', 'that', 'these', 'those'
  ]);
  
  const noisePatterns = [
    /^(isbn|copyright|©|\d{4}|\$\d+|\d+\.\d+)$/i, // ISBNs, years, prices
    /^(page|chapter|part|volume|vol|edition|ed)\s*\d*$/i, // Book structure terms
    /^(illustrated|adapted|abridged|unabridged|revised)$/i, // Publication terms
    /^(hardcover|paperback|kindle|ebook|audiobook)$/i, // Format terms
    /^(bestseller|award|winner|nominee|finalist)$/i, // Marketing terms
    /^(new|york|times|amazon|goodreads|review)$/i, // Publisher/review terms
    /^[^\w\s]+$/, // Only punctuation
    /^\d+$/ // Only numbers
  ];
  
  const cleaned = rawLines
    .map(line => line.trim())
    .filter(line => {
      // Remove very short lines
      if (line.length < 3) {
        debugLog.discarded.push({ line, reason: 'too short' });
        return false;
      }
      
      // Remove lines with only stopwords
      const words = line.toLowerCase().split(/\s+/);
      if (words.every(word => stopWords.has(word))) {
        debugLog.discarded.push({ line, reason: 'only stopwords' });
        return false;
      }
      
      // Remove lines matching noise patterns
      for (const pattern of noisePatterns) {
        if (pattern.test(line)) {
          debugLog.discarded.push({ line, reason: 'noise pattern' });
          return false;
        }
      }
      
      return true;
    })
    // Remove near-duplicates (Levenshtein distance)
    .filter((line, index, arr) => {
      const isDuplicate = arr.slice(0, index).some(prevLine => 
        calculateSimilarity(line.toLowerCase(), prevLine.toLowerCase()) > 0.8
      );
      if (isDuplicate) {
        debugLog.discarded.push({ line, reason: 'near duplicate' });
        return false;
      }
      debugLog.cleaned.push(line);
      return true;
    });
  
  return { lines: cleaned, debug: debugLog };
}

// Calculate text similarity using Levenshtein distance
function calculateSimilarity(str1, str2) {
  const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
  
  for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
  for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
  
  for (let j = 1; j <= str2.length; j++) {
    for (let i = 1; i <= str1.length; i++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i - 1] + 1,     // insertion
        matrix[j - 1][i] + 1,     // deletion
        matrix[j - 1][i - 1] + cost // substitution
      );
    }
  }
  
  const maxLen = Math.max(str1.length, str2.length);
  return maxLen === 0 ? 1 : 1 - (matrix[str2.length][str1.length] / maxLen);
}

// Group related OCR lines into potential book titles
function groupOCRLines(cleanedLines) {
  const debugLog = { groups: [], individual: [] };
  const used = new Set();
  const groups = [];
  
  // Look for title + author patterns first
  for (let i = 0; i < cleanedLines.length - 1; i++) {
    if (used.has(i)) continue;
    
    const line1 = cleanedLines[i];
    const line2 = cleanedLines[i + 1];
    
    // Check if line1 looks like a title and line2 looks like an author
    if (looksLikeTitle(line1) && looksLikeAuthor(line2)) {
      const combined = `${line1} by ${line2}`;
      groups.push({
        text: combined,
        confidence: 0.9,
        components: [line1, line2],
        type: 'title-author'
      });
      debugLog.groups.push({
        combined,
        components: [line1, line2],
        type: 'title-author',
        indices: [i, i + 1]
      });
      used.add(i);
      used.add(i + 1);
      continue;
    }
  }
  
  // Look for split titles (nearby lines with matching capitalization)
  for (let i = 0; i < cleanedLines.length - 2; i++) {
    if (used.has(i)) continue;
    
    const candidates = [];
    candidates.push(cleanedLines[i]);
    
    // Look for up to 3 nearby lines that might be part of the same title
    for (let j = i + 1; j < Math.min(i + 4, cleanedLines.length); j++) {
      if (used.has(j)) continue;
      
      const currentLine = cleanedLines[j];
      
      // Check if this line might be part of the same title
      if (mightBeSameTitle(cleanedLines[i], currentLine)) {
        candidates.push(currentLine);
      }
    }
    
    // If we found potential components, try to merge them
    if (candidates.length > 1) {
      const merged = mergeTitle(candidates);
      const confidence = calculateMergeConfidence(candidates, merged);
      
      // Only keep merges with reasonable confidence
      if (confidence > 0.6) {
        groups.push({
          text: merged,
          confidence: confidence,
          components: candidates,
          type: 'split-title'
        });
        
        debugLog.groups.push({
          combined: merged,
          components: candidates,
          type: 'split-title',
          confidence: confidence
        });
        
        // Mark all components as used
        candidates.forEach(component => {
          const index = cleanedLines.indexOf(component);
          if (index !== -1) used.add(index);
        });
        continue;
      }
    }
  }
  
  // Add remaining individual lines
  cleanedLines.forEach((line, index) => {
    if (!used.has(index)) {
      groups.push({
        text: line,
        confidence: looksLikeTitle(line) ? 0.7 : 0.5,
        components: [line],
        type: 'individual'
      });
      debugLog.individual.push({ line, index });
    }
  });
  
  // Sort by confidence (highest first)
  groups.sort((a, b) => b.confidence - a.confidence);
  
  return { groups, debug: debugLog };
}

// Check if a line looks like a book title
function looksLikeTitle(line) {
  const titlePatterns = [
    /^[A-Z][a-z]/, // Starts with capital letter
    /[A-Z][a-z]+(?:\s+[A-Z][a-z]*)*/, // Title case pattern
    /^(the|a|an)\s+[A-Z]/i, // Articles followed by capitals
  ];
  
  const hasNumbers = /\d/.test(line);
  const hasArticles = /^(the|a|an)\s+/i.test(line);
  const reasonableLength = line.length >= 4 && line.length <= 100;
  
  return titlePatterns.some(pattern => pattern.test(line)) && 
         !hasNumbers && reasonableLength;
}

// Check if a line looks like an author name
function looksLikeAuthor(line) {
  const authorPatterns = [
    /^[A-Z][a-z]+(?:\s+[A-Z]\.?)*(?:\s+[A-Z][a-z]+)+$/, // First M. Last or First Last
    /^[A-Z]\.\s*[A-Z]\.\s*[A-Z][a-z]+$/, // J.K. Rowling style
    /^by\s+[A-Z]/i, // Starts with "by"
  ];
  
  const hasCommonNames = /\b(john|jane|mary|david|michael|sarah|elizabeth|robert|william|james)\b/i.test(line);
  const reasonableLength = line.length >= 4 && line.length <= 50;
  
  return (authorPatterns.some(pattern => pattern.test(line)) || hasCommonNames) && 
         reasonableLength;
}

// Check if two lines might be parts of the same title
function mightBeSameTitle(line1, line2) {
  const both = [line1, line2].map(l => l.trim().toUpperCase());
  
  // Similar capitalization patterns
  const cap1 = line1.replace(/[^A-Z]/g, '');
  const cap2 = line2.replace(/[^A-Z]/g, '');
  const similarCaps = cap1.length > 0 && cap2.length > 0 && 
                      Math.abs(cap1.length - cap2.length) <= 1;
  
  // One might be a connecting word or preposition
  const connectingWords = ['of', 'the', 'and', 'in', 'on', 'at', 'to', 'for', 'with'];
  const isConnector = connectingWords.some(word => 
    both[1].includes(word.toUpperCase()) && both[1].split(/\s+/).length <= 2
  );
  
  // Both are short and might be fragments
  const bothShort = line1.length <= 15 && line2.length <= 15;
  
  return similarCaps || isConnector || bothShort;
}

// Merge title components intelligently
function mergeTitle(components) {
  // Sort components by likely order (longer/more complete parts first)
  const sorted = components.slice().sort((a, b) => {
    // Prefer lines that look more like main title parts
    const aScore = looksLikeTitle(a) ? 1 : 0;
    const bScore = looksLikeTitle(b) ? 1 : 0;
    if (aScore !== bScore) return bScore - aScore;
    
    // Then by length
    return b.length - a.length;
  });
  
  // Smart joining - detect if we need connecting words
  let merged = sorted[0];
  for (let i = 1; i < sorted.length; i++) {
    const next = sorted[i];
    
    // Skip if it's already contained in the merged title
    if (merged.toLowerCase().includes(next.toLowerCase())) continue;
    
    // Add connecting words if needed
    const needsConnection = !merged.endsWith(' ') && !next.startsWith(' ') &&
                           !/^(of|the|and|in|on|at|to|for|with)$/i.test(next);
    
    merged += needsConnection ? ` ${next}` : next;
  }
  
  return merged.trim().replace(/\s+/g, ' ');
}

// Calculate confidence for a merged title
function calculateMergeConfidence(components, merged) {
  let confidence = 0.5; // Base confidence
  
  // Boost for title-like appearance of result
  if (looksLikeTitle(merged)) confidence += 0.2;
  
  // Boost for reasonable length
  if (merged.length >= 8 && merged.length <= 80) confidence += 0.1;
  
  // Boost for multiple meaningful components
  if (components.length >= 2) confidence += 0.1;
  if (components.length >= 3) confidence += 0.1;
  
  // Penalty for too many components (likely noise)
  if (components.length > 4) confidence -= 0.2;
  
  return Math.max(0, Math.min(1, confidence));
}

// Main OCR processing function
function processOCRText(rawLines) {
  const cleaning = cleanOCRLines(rawLines);
  const grouping = groupOCRLines(cleaning.lines);
  
  const processed = {
    queries: grouping.groups.map(group => group.text),
    debug: {
      original: rawLines,
      cleaning: cleaning.debug,
      grouping: grouping.debug,
      finalGroups: grouping.groups
    }
  };
  
  return processed;
}

/* ========== OCR + GOOGLE BOOKS (Scanner) ========== */
async function processImage(e){
  const file=e.target.files[0]; if(!file)return;
  const statusMsg=document.getElementById("statusMsg");
  const output=document.getElementById("output");
  statusMsg.textContent="Processing image…";
  const reader=new FileReader();
  reader.onloadend=async()=>{
    const b64=reader.result.split(",")[1];
    try{
      const res=await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${API_KEY}`,{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({requests:[{image:{content:b64},features:[{type:"DOCUMENT_TEXT_DETECTION"}]}]})
      });
      const json=await res.json();
      const blocks=json.responses?.[0]?.fullTextAnnotation?.pages?.[0]?.blocks||[];
      let rawLines=[];
      for(const b of blocks){
        let t=""; b.paragraphs.forEach(p=>p.words.forEach(w=>t+=w.symbols.map(s=>s.text).join("")+" "));
        t=t.trim();
        if(t.length>0)rawLines.push(t);
      }
      
      // Process OCR text with new intelligent cleaning and grouping
      const processed = processOCRText(rawLines);
      
      output.textContent = processed.queries.join("\n") || "(No text detected)";
      
      // Store debug info for transparency
      window.lastOCRDebug = processed.debug;
      console.log("OCR Processing Debug:", processed.debug);
      
      buildSearchForm(processed.queries, processed.debug);
    }catch(err){console.error(err);output.textContent="OCR error.";}
    statusMsg.textContent="";
  };
  reader.readAsDataURL(file);
}

function buildSearchForm(queries, debug){
  const results = document.getElementById("results");
  results.innerHTML="<h2>Processed OCR Results</h2>";
  
  // Add debug toggle if debug info is available
  if (debug) {
    const debugToggle = document.createElement("button");
    debugToggle.type = "button";
    debugToggle.textContent = "Show Processing Details";
    debugToggle.style.cssText = "margin-bottom: 10px; background: #f0f0f0; border: 1px solid #ccc; padding: 5px 10px; cursor: pointer;";
    
    const debugInfo = document.createElement("div");
    debugInfo.style.display = "none";
    debugInfo.style.cssText = "background: #f9f9f9; border: 1px solid #ddd; padding: 10px; margin: 10px 0; font-family: monospace; font-size: 12px; white-space: pre-wrap;";
    
    debugToggle.onclick = () => {
      if (debugInfo.style.display === "none") {
        debugInfo.style.display = "block";
        debugToggle.textContent = "Hide Processing Details";
        
        let debugText = `📊 OCR Processing Summary:\n\n`;
        debugText += `Original lines detected: ${debug.original.length}\n`;
        debugText += `Lines discarded: ${debug.cleaning.discarded.length}\n`;
        debugText += `Lines cleaned: ${debug.cleaning.cleaned.length}\n`;
        debugText += `Final grouped queries: ${queries.length}\n\n`;
        
        if (debug.cleaning.discarded.length > 0) {
          debugText += `🗑️ Discarded lines:\n`;
          debug.cleaning.discarded.forEach(item => {
            debugText += `  • "${item.line}" (${item.reason})\n`;
          });
          debugText += `\n`;
        }
        
        if (debug.grouping.groups.length > 0) {
          debugText += `🔗 Grouped combinations:\n`;
          debug.grouping.groups.forEach(group => {
            debugText += `  • Type: ${group.type}\n`;
            debugText += `    Combined: "${group.combined}"\n`;
            debugText += `    From: [${group.components.join(', ')}]\n`;
            if (group.confidence) debugText += `    Confidence: ${(group.confidence * 100).toFixed(1)}%\n`;
            debugText += `\n`;
          });
        }
        
        if (debug.grouping.individual.length > 0) {
          debugText += `📝 Individual lines kept:\n`;
          debug.grouping.individual.forEach(item => {
            debugText += `  • "${item.line}"\n`;
          });
        }
        
        debugInfo.textContent = debugText;
      } else {
        debugInfo.style.display = "none";
        debugToggle.textContent = "Show Processing Details";
      }
    };
    
    results.appendChild(debugToggle);
    results.appendChild(debugInfo);
  }
  
  const form=document.createElement("form");form.id="searchForm";
  queries.forEach((query,i)=>{
    const wrap=document.createElement("div");wrap.className="flex";wrap.style.cssText="margin: 5px 0; align-items: center;";
    
    const inp=document.createElement("input");
    inp.value=query;
    inp.name=`t${i}`;
    inp.style.flex="1";
    inp.style.marginRight="10px";
    
    const x=document.createElement("button");
    x.type="button";
    x.textContent="❌";
    x.style.cssText="background: #ff4444; color: white; border: none; padding: 5px 8px; cursor: pointer; border-radius: 3px;";
    x.onclick=()=>wrap.remove();
    
    wrap.append(inp,x);
    form.appendChild(wrap);
  });
  
  const submitBtn = document.createElement("button");
  submitBtn.textContent="Search Books";
  submitBtn.style.cssText="margin-top: 10px; padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer; border-radius: 3px;";
  form.appendChild(submitBtn);
  
  results.appendChild(form);
}

document.addEventListener("submit",e=>{
  if(e.target.id==="searchForm"){e.preventDefault();
    const titles=[...new FormData(e.target).values()]
      .map(v=>v.trim().replace(/[^\w\s'":,.!?-]/g,"").replace(/\s+/g," "))
      .filter(v=>v.length>2);
    searchBooks([...new Set(titles)]);
  }
  if(e.target.id==="historyForm"){e.preventDefault();addHistoryEntry(new FormData(e.target));}
});

/* ---------- Google Books search for Scanner ---------- */
async function searchBooks(titles){
  const results = document.getElementById("results");
  results.innerHTML="<p>Searching Google Books…</p>";
  const books=[];
  for(const t of titles){
    try{
      const url=`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(t)}&maxResults=1&key=${API_KEY}`;
      const j=await fetch(url).then(r=>r.json());
      const v=j.items?.[0]?.volumeInfo;
      if(v)books.push({title:v.title,authors:(v.authors||[]).join(", "),
        rating:v.averageRating||"N/A",thumb:v.imageLinks?.thumbnail||"",categories:(v.categories||[]).map(c=>c.trim()),query:t});
    }catch(e){console.error(e);}
  }
  showSearchResults(books);
}

function showSearchResults(books){
  // Rank books before rendering
  const rankedBooks = rankScannedBooks(books);
  const results = document.getElementById("results");
  results.innerHTML="<h2>Book Matches</h2>";
  const genres=[...new Set(rankedBooks.flatMap(b=>b.categories))].sort();
  if(genres.length){
    const lab=document.createElement("label");lab.textContent="Filter:";
    const sel=document.createElement("select");sel.id="genreFilter";
    sel.innerHTML="<option value='all'>All</option>"+genres.map(g=>`<option>${g}</option>`).join("");
    sel.onchange=()=>renderCards(rankedBooks);
    results.append(lab,sel);
  }
  const sortSel=document.createElement("select");sortSel.id="sortFilter";
  sortSel.innerHTML=`<option value="rank-desc">Best Match</option>
                     <option value="t-asc">Title A→Z</option>
                     <option value="t-desc">Title Z→A</option>
                     <option value="r-desc">Rating ↑</option>
                     <option value="r-asc">Rating ↓</option>`;
  sortSel.onchange=()=>renderCards(rankedBooks);
  
  const helpLink = document.createElement("a");
  helpLink.href = "#";
  helpLink.textContent = "How does ranking work?";
  helpLink.style.cssText = "margin-left:10px;color:var(--accent);font-size:0.9em;text-decoration:underline;cursor:pointer;";
  helpLink.onclick = (e) => { e.preventDefault(); showRankingHelp(); };
  
  results.append(sortSel, helpLink);
  renderCards(rankedBooks);
}

function renderCards(list){
  const results = document.getElementById("results");
  results.querySelectorAll(".book-card").forEach(n=>n.remove());
  const g=results.querySelector("#genreFilter")?.value||"all";
  const s=results.querySelector("#sortFilter")?.value||"rank-desc";
  let books=[...list]; if(g!=="all")books=books.filter(b=>b.categories.includes(g));
  const sorters={
    "rank-desc":(a,b)=>(b.rankScore||0)-(a.rankScore||0),
    "t-asc":(a,b)=>a.title.localeCompare(b.title),
    "t-desc":(a,b)=>b.title.localeCompare(a.title),
    "r-desc":(a,b)=>(b.rating||0)-(a.rating||0),
    "r-asc":(a,b)=>(a.rating||0)-(b.rating||0)
  };
  books.sort(sorters[s]);
  books.forEach(b=>{
    const c=document.createElement("div");c.className="book-card";
    c.innerHTML=`<strong>Matched:</strong> "${b.query}"<br>${b.thumb?`<img src="${b.thumb}" style="height:100px"><br>`:""}
      <strong>${b.title}</strong><br>by ${b.authors}<br>Rating: ${b.rating}<br>
      ${b.categories.length?`<em>${b.categories.join(", ")}</em><br>`:""}
      <span style="color:gray">Match Score: <span id="score-${Math.random().toString(36).substr(2,9)}" style="cursor:pointer;text-decoration:underline;font-weight:bold;" onclick="showScoreBreakdown(this, ${JSON.stringify(b.scoreBreakdown).replace(/"/g, '&quot;')})">${(b.rankScore||0).toFixed(1)}/10</span></span>`;
    const save=Object.assign(document.createElement("button"),{textContent:"Save to My List",onclick:()=>saveBook(b)});
    c.appendChild(save);results.appendChild(c);
  });
}

/* ========== SAVED LIST (unchanged) ========== */
const getSaved=()=>JSON.parse(localStorage.getItem("savedBooks")||"[]");
const setSaved=l=>localStorage.setItem("savedBooks",JSON.stringify(l));
function saveBook(b){const l=getSaved();if(!l.some(x=>x.title===b.title&&x.authors===b.authors)){l.push(b);setSaved(l);}showSaved();}
function showSaved(){
  const wrap=document.getElementById("savedList"),ctl=document.getElementById("savedControls");wrap.innerHTML="";ctl.innerHTML="";
  const list=getSaved();
  if(!list.length){wrap.innerHTML="<p>No saved books.</p>";return;}
  const sort=document.createElement("select");sort.id="savedSort";
  sort.innerHTML=`<option value="t-asc">Title A→Z</option><option value="t-desc">Title Z→A</option>
                  <option value="r-desc">Rating ↑</option><option value="r-asc">Rating ↓</option>`;
  sort.onchange=showSaved;ctl.append(sort,
    mkBtn("📄 Export CSV",exportCSV),mkBtn("📄 Export JSON",exportJSON),
    mkBtn("🗑️ Clear All",()=>{setSaved([]);showSaved();}));
  const sorter={"t-asc":(a,b)=>a.title.localeCompare(b.title),"t-desc":(a,b)=>b.title.localeCompare(a.title),
                "r-desc":(a,b)=>(b.rating||0)-(a.rating||0),"r-asc":(a,b)=>(a.rating||0)-(b.rating||0)};
  list.sort(sorter[sort.value]);
  list.forEach((b,i)=>{
    const card=document.createElement("div");card.className="book-card";
    card.innerHTML=`${b.thumb?`<img src="${b.thumb}" style="height:80px"><br>`:""}
      <strong>${b.title}</strong><br>by ${b.authors}<br>Rating: ${b.rating}<br>`;
    card.appendChild(mkBtn("Remove",()=>{list.splice(i,1);setSaved(list);showSaved();}));
    wrap.appendChild(card);
  });
}
function exportCSV(){const l=getSaved();const rows=[["Title","Authors","Rating","Categories"]];
  l.forEach(b=>rows.push([b.title,b.authors,b.rating,b.categories.join("|")]));download(rows,"saved_books.csv","text/csv");}
function exportJSON(){download(JSON.stringify(getSaved(),null,2),"saved_books.json","application/json");}
function download(content,name,type){
  const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([content],{type}));a.download=name;a.click();URL.revokeObjectURL(a.href);}
const mkBtn=(txt,fn)=>Object.assign(document.createElement("button"),{textContent:txt,onclick:fn});

/* ========== READING HISTORY WITH LIVE SEARCH ========== */
const searchBox=document.getElementById("bookSearch"),srDiv=document.getElementById("searchResults");
let searchTimer;
searchBox.addEventListener("input",()=>{clearTimeout(searchTimer);
  const q=searchBox.value.trim(); if(q.length<3){srDiv.style.display="none";return;}
  searchTimer=setTimeout(()=>fetchGB(q),400);
});
async function fetchGB(q){
  const url=`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}&maxResults=5&key=${API_KEY}`;
  const res=await fetch(url);const data=await res.json();
  const items=data.items||[];srDiv.innerHTML="";if(!items.length){srDiv.style.display="none";return;}
  items.forEach(item=>{
    const v=item.volumeInfo;const div=document.createElement("div");div.className="sr-item";
    div.innerHTML=`${v.imageLinks?`<img src='${v.imageLinks.thumbnail}'>`:""}
      <div><strong>${v.title}</strong><br>${(v.authors||[]).join(", ")}</div>`;
    div.onclick=()=>{const f=document.forms["historyForm"];f.title.value=v.title||"";f.author.value=(v.authors||[]).join(", ");f.genre.value=v.categories?.[0]||"";srDiv.style.display="none";searchBox.value="";};
    srDiv.appendChild(div);
  });
  srDiv.style.display="block";
}
document.addEventListener("click",e=>{if(!searchBox.contains(e.target)&&!srDiv.contains(e.target))srDiv.style.display="none";});

const getHistory=()=>JSON.parse(localStorage.getItem("readingHistory")||"[]");
const setHistory=l=>localStorage.setItem("readingHistory",JSON.stringify(l));
function addHistoryEntry(fd){
  const entry={title:fd.get("title"),author:fd.get("author")||"Unknown",rating:+fd.get("rating"),genre:fd.get("genre")||""};
  const list=getHistory();list.push(entry);setHistory(list);showHistory();document.getElementById("historyForm").reset();
}
function showHistory(){
  const wrap=document.getElementById("historyList");wrap.innerHTML="";const list=getHistory();
  if(!list.length){wrap.innerHTML="<p>No entries yet.</p>";return;}
  list.forEach((b,i)=>{
    const card=document.createElement("div");card.className="book-card";
    const rating = Number(b.rating) || 0;
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.5 ? 1 : 0;
    const emptyStars = 5 - fullStars - halfStar;
    const starDisplay = "★".repeat(fullStars) + (halfStar ? "☆" : "") + "☆".repeat(emptyStars);
    
    card.innerHTML=`<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
      ${b.thumbnail ? `<img src="${b.thumbnail}" style="height:80px;width:60px;object-fit:cover;cursor:pointer;border:2px solid #ccc;border-radius:4px;" onclick="editThumbnail(${i})" title="Click to edit thumbnail">` : 
        `<div style="height:80px;width:60px;background:#f0f0f0;border:2px dashed #ccc;border-radius:4px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:12px;text-align:center;color:#666;" onclick="editThumbnail(${i})" title="Click to add thumbnail">Add<br>Image</div>`}
      <div style="flex:1;">
        <strong>${b.title}</strong><br>
        by ${b.author}<br>
        Rating: ${starDisplay} (${rating})<br>
        ${b.genre?`<em>${b.genre}</em><br>`:""}
      </div>
    </div>`;
    const btnContainer = document.createElement("div");
    btnContainer.style.display = "flex";
    btnContainer.style.gap = "5px";
    btnContainer.appendChild(mkBtn("Edit", ()=>editHistoryEntry(i)));
    btnContainer.appendChild(mkBtn("Remove",()=>{list.splice(i,1);setHistory(list);showHistory();}));
    card.appendChild(btnContainer);
    wrap.appendChild(card);
  });
}

function editThumbnail(index) {
  const url = prompt("Enter image URL for thumbnail:");
  if (url) {
    const list = getHistory();
    list[index].thumbnail = url;
    setHistory(list);
    showHistory();
  }
}

function editHistoryEntry(index) {
  const list = getHistory();
  const entry = list[index];
  
  const newTitle = prompt("Edit title:", entry.title);
  if (newTitle === null) return; // User cancelled
  
  const newAuthor = prompt("Edit author:", entry.author);
  if (newAuthor === null) return;
  
  const newRating = prompt("Edit rating (0.5 to 5, with 0.5 increments):", entry.rating);
  if (newRating === null) return;
  
  const newGenre = prompt("Edit genres (comma-separated):", entry.genre);
  if (newGenre === null) return;
  
  // Validate rating
  const ratingNum = parseFloat(newRating);
  if (isNaN(ratingNum) || ratingNum < 0.5 || ratingNum > 5 || (ratingNum * 2) % 1 !== 0) {
    alert("Please enter a valid rating between 0.5 and 5 with 0.5 increments (e.g., 3.5, 4, 4.5)");
    return;
  }
  
  // Update entry
  list[index] = {
    ...entry,
    title: newTitle.trim(),
    author: newAuthor.trim(),
    rating: ratingNum,
    genre: newGenre.trim()
  };
  
  setHistory(list);
  showHistory();
}

/* ========== CSV IMPORT/EXPORT FUNCTIONS ========== */
async function importCSV(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const text = await file.text();
  const lines = text.split('\n').filter(line => line.trim());
  
  if (lines.length < 2) {
    alert("CSV file appears to be empty or invalid.");
    return;
  }
  
  const headers = lines[0].split(',').map(h => h.trim().toLowerCase().replace(/"/g, ''));
  const existingHistory = getHistory();
  let importedCount = 0;
  
  // Common header variations for different services
  const titleHeaders = ['title', 'book title', 'name'];
  const authorHeaders = ['author', 'authors', 'book author'];
  const ratingHeaders = ['rating', 'my rating', 'user rating', 'personal rating'];
  const genreHeaders = ['genre', 'genres', 'categories', 'subjects', 'bookshelves'];
  
  const titleIndex = headers.findIndex(h => titleHeaders.some(th => h.includes(th)));
  const authorIndex = headers.findIndex(h => authorHeaders.some(ah => h.includes(ah)));
  const ratingIndex = headers.findIndex(h => ratingHeaders.some(rh => h.includes(rh)));
  const genreIndex = headers.findIndex(h => genreHeaders.some(gh => h.includes(gh)));
  
  if (titleIndex === -1) {
    alert("Could not find a title column. Please ensure your CSV has a 'Title' column.");
    return;
  }
  
  for (let i = 1; i < lines.length; i++) {
    const cells = parseCSVLine(lines[i]);
    if (cells.length <= titleIndex) continue;
    
    const title = cells[titleIndex]?.trim();
    if (!title) continue;
    
    // Check if book already exists
    const existingBook = existingHistory.find(book => 
      book.title.toLowerCase() === title.toLowerCase()
    );
    
    if (existingBook) continue; // Skip duplicates
    
    const author = authorIndex >= 0 ? cells[authorIndex]?.trim() || "Unknown" : "Unknown";
    let rating = 3; // Default rating
    
    if (ratingIndex >= 0 && cells[ratingIndex]) {
      const ratingValue = parseFloat(cells[ratingIndex]);
      if (!isNaN(ratingValue) && ratingValue >= 0.5 && ratingValue <= 5) {
        // Round to nearest 0.5
        rating = Math.round(ratingValue * 2) / 2;
      }
    }
    
    const genre = genreIndex >= 0 ? cells[genreIndex]?.trim() || "" : "";
    
    const entry = {
      title,
      author,
      rating,
      genre
    };
    
    existingHistory.push(entry);
    importedCount++;
  }
  
  setHistory(existingHistory);
  showHistory();
  alert(`Successfully imported ${importedCount} books from CSV!`);
}

function parseCSVLine(line) {
  const cells = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      cells.push(current.trim().replace(/^"|"$/g, ''));
      current = '';
    } else {
      current += char;
    }
  }
  
  cells.push(current.trim().replace(/^"|"$/g, ''));
  return cells;
}

function exportHistory() {
  const history = getHistory();
  if (!history.length) {
    alert("No reading history to export.");
    return;
  }
  
  const headers = ['Title', 'Author', 'Rating', 'Genres'];
  const csvContent = [
    headers.join(','),
    ...history.map(book => [
      `"${book.title}"`,
      `"${book.author}"`,
      book.rating,
      `"${book.genre}"`
    ].join(','))
  ].join('\n');
  
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `bookwise-reading-history-${new Date().toISOString().split('T')[0]}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

function showCSVFormat() {
  const example = `Here are the CSV formats supported:

**Goodreads Export Format:**
Title,Author,My Rating,Bookshelves
"The Hobbit","J.R.R. Tolkien",5,"fantasy, adventure"
"1984","George Orwell",4.5,"dystopian, classics"

**Simple Format:**
Title,Author,Rating,Genre
"Dune","Frank Herbert",4.5,"Science Fiction"
"Pride and Prejudice","Jane Austen",4,"Romance, Classics"

**Required:**
- Title column (required)
- Author column (optional, defaults to "Unknown")
- Rating column (optional, defaults to 3.0)
- Genre/Categories column (optional)

**Notes:**
- Ratings will be rounded to nearest 0.5 (e.g., 4.3 becomes 4.5)
- Duplicate books (same title) will be skipped
- CSV should have headers in the first row`;
  
  alert(example);
}

function showRankingHelp() {
  const history = getHistory();
  const hasHistory = history.length > 0;
  
  let explanation = `📊 **How BookWise Ranking Works**

BookWise creates personalized match scores based on your reading history to help you find books you'll love!

`;

  if (hasHistory) {
    const likedCount = history.filter(book => Number(book.rating) >= 4).length;
    const dislikedCount = history.filter(book => Number(book.rating) <= 2).length;
    
    explanation += `**Your Reading Profile:**
📚 ${history.length} books in your history
👍 ${likedCount} books you loved (4-5 stars)
👎 ${dislikedCount} books you didn't enjoy (1-2 stars)

**Scoring System:**
🎯 **Genre Matching:**
  +2 points: Shares genre with books you rated 4-5 stars
  -2 points: Shares genre with books you rated 1-2 stars

👨‍💼 **Author Matching:**
  +1 point: Author you've rated highly before
  -1 point: Author you've rated poorly before

**Example:** If you loved "Dune" (Sci-Fi, 5 stars), then:
• "The Martian" (Sci-Fi) gets +2 points
• Another Frank Herbert book gets +3 points (+2 genre, +1 author)

**Higher scores = Better matches for YOU!**`;
  } else {
    explanation += `**Getting Started:**
🔄 Match scores are currently 0 because you haven't added any books to your reading history yet.

📖 **To get personalized recommendations:**
1. Go to "📚 Reading History" tab
2. Add books you've read with ratings
3. Import your Goodreads CSV for instant personalization!

**Once you have reading history:**
• Books matching your favorite genres get higher scores
• Books by authors you love get bonus points
• Books similar to ones you disliked get lower scores

The more books you add, the smarter the recommendations become! 🎯`;
  }
  
  alert(explanation);
}

function showScoreBreakdown(element, breakdown) {
  if (!breakdown) {
    alert("Score breakdown not available for this book.");
    return;
  }
  
  let explanation = `📊 **Score Breakdown** (Out of 10)\n\n`;
  
  if (breakdown.explanation) {
    explanation += breakdown.explanation;
  } else {
    explanation += `**Your Reading History Analysis:**\n\n`;
    
    if (breakdown.genreDetails && breakdown.genreDetails.length > 0) {
      explanation += `🎭 **Genre Preferences:**\n`;
      breakdown.genreDetails.forEach(detail => {
        explanation += `• ${detail}\n`;
      });
      explanation += `\n`;
    }
    
    if (breakdown.authorDetails && breakdown.authorDetails.length > 0) {
      explanation += `✍️ **Author Experience:**\n`;
      breakdown.authorDetails.forEach(detail => {
        explanation += `• ${detail}\n`;
      });
      explanation += `\n`;
    }
    
    if (breakdown.keywordDetails && breakdown.keywordDetails.length > 0) {
      explanation += `🔍 **Thematic Matching:**\n`;
      breakdown.keywordDetails.forEach(detail => {
        explanation += `• ${detail}\n`;
      });
      explanation += `\n`;
    }
    
    if ((!breakdown.genreDetails || breakdown.genreDetails.length === 0) && 
        (!breakdown.authorDetails || breakdown.authorDetails.length === 0) &&
        (!breakdown.keywordDetails || breakdown.keywordDetails.length === 0)) {
      explanation += `⚪ No specific genre, author, or thematic matches found in your reading history\n\n`;
    }
    
    explanation += `**Score Components:**\n`;
    
    if (breakdown.preferenceScore !== 0) {
      const prefText = breakdown.preferenceScore > 0 ? "positive" : "negative";
      explanation += `📈 Personal Preferences: ${breakdown.preferenceScore > 0 ? '+' : ''}${breakdown.preferenceScore.toFixed(1)} pts (${prefText} based on similar books you've read)\n`;
    }
    
    if (breakdown.offlineBonus > 0) {
      explanation += `📚 Offline Recommendations: +${breakdown.offlineBonus.toFixed(1)} pts (related books in database)\n`;
    }
    
    explanation += `\n**Final Calculation:**\n`;
    explanation += `Raw Score: ${breakdown.total.toFixed(2)}\n`;
    explanation += `Scaled Score: ${breakdown.scaledTotal.toFixed(1)}/10\n\n`;
    explanation += `💡 **How it works:** Instead of just looking at genres broadly, BookWise analyzes your ratings for individual books within each genre and author to give you truly personalized recommendations!`;
  }
  
  alert(explanation);
}

/* ---------- BOOK SIMILARITY FUNCTION ---------- */
function bookSimilarity(bookA, bookB) {
  let score = 0;
  // Title similarity
  if (bookA.title && bookB.title) {
    const a = bookA.title.toLowerCase(), b = bookB.title.toLowerCase();
    if (a === b) score += 3;
    else if (a.includes(b) || b.includes(a)) score += 2;
  }
  // Author similarity
  if (bookA.authors && bookB.author) {
    const a = bookA.authors.toLowerCase(), b = bookB.author.toLowerCase();
    if (a === b) score += 2;
    else if (a.includes(b) || b.includes(a)) score += 1;
  }
  // Genre similarity
  if (bookA.categories && bookB.genre) {
    if (bookA.categories.some(cat => cat.toLowerCase() === bookB.genre.toLowerCase())) score += 1;
  }
  return score;
}

function rankScannedBooks(scannedBooks) {
  const history = getHistory();
  
  if (!history.length) {
    return scannedBooks.map(book => ({...book, rankScore: 0}));
  }
  
  // Categorize books by rating for preference analysis
  const likedBooks = history.filter(book => Number(book.rating) >= 4);
  const dislikedBooks = history.filter(book => Number(book.rating) <= 2);
  
  // Extract genres and authors for comparison
  const likedGenres = new Set();
  const dislikedGenres = new Set();
  const likedAuthors = new Set();
  const dislikedAuthors = new Set();
  
  likedBooks.forEach(book => {
    if (book.genre) {
      book.genre.split(',').forEach(genre => 
        likedGenres.add(genre.trim().toLowerCase())
      );
    }
    if (book.author) {
      likedAuthors.add(book.author.trim().toLowerCase());
    }
  });
  
  dislikedBooks.forEach(book => {
    if (book.genre) {
      book.genre.split(',').forEach(genre => 
        dislikedGenres.add(genre.trim().toLowerCase())
      );
    }
    if (book.author) {
      dislikedAuthors.add(book.author.trim().toLowerCase());
    }
  });
  
  return scannedBooks.map(book => {
    let rankScore = 0;
    
    // Advanced preference scoring - considers individual books within genres
    const preferenceScore = calculateAdvancedPreferenceScore(book, history);
    rankScore += preferenceScore;
    
    // Offline dataset enhancement scoring
    const offlineBonus = getOfflineRecommendationBonus(book, history);
    rankScore += offlineBonus;
    
    // Scale score to be out of 10 (approximate max would be around 5-6, so multiply by ~1.7)
    const scaledScore = Math.min(Math.max(rankScore * 1.7, 0), 10);
    
    // Store breakdown for tooltip
    const scoreBreakdown = calculateScoreBreakdown(book, history, rankScore, offlineBonus, preferenceScore);
    
    return {...book, rankScore: scaledScore, scoreBreakdown};
  });
}

/* ========== ADVANCED PREFERENCE SCORING ========== */
function calculateAdvancedPreferenceScore(scannedBook, userHistory) {
  if (!userHistory.length || !scannedBook.categories) return 0;
  
  let totalScore = 0;
  const bookCategories = scannedBook.categories.map(cat => cat.toLowerCase());
  const bookAuthors = scannedBook.authors ? scannedBook.authors.toLowerCase() : '';
  
  // For each category of the scanned book, calculate a nuanced score
  bookCategories.forEach(scannedCategory => {
    let categoryScore = 0;
    let categoryVotes = 0;
    
    // Extract specific tags/themes from the scanned category
    const scannedTags = extractTags(scannedCategory);
    
    // Look at all books in user's history that share this genre OR similar tags
    userHistory.forEach(historyBook => {
      const historyGenres = historyBook.genre ? 
        historyBook.genre.split(',').map(g => g.trim().toLowerCase()) : [];
      const historyAuthor = historyBook.author ? historyBook.author.toLowerCase() : '';
      const rating = Number(historyBook.rating) || 3;
      
      // Check for both genre match AND tag overlap
      const genreMatch = historyGenres.some(hg => 
        hg.includes(scannedCategory) || scannedCategory.includes(hg)
      );
      
      const tagOverlap = calculateTagOverlap(scannedTags, historyGenres);
      
      if (genreMatch || tagOverlap.score > 0) {
        categoryVotes++;
        
        // Weight the vote based on rating, similarity, and tag overlap
        let voteWeight = 1;
        
        // Stronger weight if it's the same author
        if (bookAuthors && historyAuthor && 
            (bookAuthors.includes(historyAuthor) || historyAuthor.includes(bookAuthors))) {
          voteWeight = 2;
        }
        
        // Boost weight for strong tag overlap
        if (tagOverlap.score > 0.5) {
          voteWeight *= (1 + tagOverlap.score);
        }
        
        // Convert rating to preference score (-2 to +2 scale)
        let preferenceValue = 0;
        if (rating >= 4.5) preferenceValue = 2;
        else if (rating >= 3.5) preferenceValue = 1;
        else if (rating >= 2.5) preferenceValue = 0;
        else if (rating >= 1.5) preferenceValue = -1;
        else preferenceValue = -2;
        
        categoryScore += preferenceValue * voteWeight;
      }
    });
    
    // Calculate weighted average for this category
    if (categoryVotes > 0) {
      const avgCategoryScore = categoryScore / categoryVotes;
      totalScore += avgCategoryScore;
    }
  });
  
  // Author scoring (independent of genre)
  if (bookAuthors) {
    let authorScore = 0;
    let authorVotes = 0;
    let totalAuthorRating = 0;
    
    // Find ALL books by this author in user's history
    userHistory.forEach(historyBook => {
      const historyAuthor = historyBook.author ? historyBook.author.toLowerCase() : '';
      
      if (historyAuthor && 
          (bookAuthors.includes(historyAuthor) || historyAuthor.includes(bookAuthors))) {
        const rating = Number(historyBook.rating) || 3;
        authorVotes++;
        totalAuthorRating += rating;
      }
    });
    
    // Calculate average rating for this author and convert to preference score
    if (authorVotes > 0) {
      const avgAuthorRating = totalAuthorRating / authorVotes;
      
      // Convert average rating to preference score (-2 to +2 scale)
      let authorPreference = 0;
      if (avgAuthorRating >= 4.5) authorPreference = 2;
      else if (avgAuthorRating >= 3.5) authorPreference = 1;
      else if (avgAuthorRating >= 2.5) authorPreference = 0;
      else if (avgAuthorRating >= 1.5) authorPreference = -1;
      else authorPreference = -2;
      
      // Weight the score by confidence (more books = more reliable)
      const confidenceWeight = Math.min(authorVotes / 3, 1); // Caps at 1 for 3+ books
      totalScore += authorPreference * confidenceWeight;
    }
  }
  
  // Keyword-based description matching for thematic similarity
  if (scannedBook.description || scannedBook.subtitle) {
    const scannedDescription = (scannedBook.description || '') + ' ' + (scannedBook.subtitle || '');
    const scannedKeywords = extractKeywords(scannedDescription);
    
    if (scannedKeywords.length > 0) {
      let keywordScore = 0;
      let keywordVotes = 0;
      
      // Compare with highly-rated books in user's history
      userHistory.forEach(historyBook => {
        const rating = Number(historyBook.rating) || 3;
        
        // Only consider books rated 3.5+ for positive keyword associations
        if (rating >= 3.5 && historyBook.title) {
          // Use title + genre as description proxy (since we don't have full descriptions)
          const historyDescription = historyBook.title + ' ' + (historyBook.genre || '');
          const historyKeywords = extractKeywords(historyDescription);
          
          const keywordOverlap = calculateKeywordOverlap(scannedKeywords, historyKeywords);
          
          if (keywordOverlap.score > 0) {
            keywordVotes++;
            
            // Convert rating to preference score
            let preferenceValue = 0;
            if (rating >= 4.5) preferenceValue = 1.5;
            else if (rating >= 4.0) preferenceValue = 1.0;
            else preferenceValue = 0.5;
            
            // Weight by keyword overlap strength
            keywordScore += preferenceValue * keywordOverlap.score;
          }
        }
      });
      
      // Add keyword score with diminishing returns to prevent overwhelming other factors
      if (keywordVotes > 0) {
        const avgKeywordScore = keywordScore / keywordVotes;
        totalScore += Math.min(avgKeywordScore, 1); // Cap keyword contribution at +1
      }
    }
  }
  
  return totalScore;
}

/* ========== TAG-BASED PREFERENCE FUNCTIONS ========== */
function extractTags(genreText) {
  const text = genreText.toLowerCase();
  const tags = [];
  
  // Define comprehensive tag patterns for specific themes/subgenres
  const tagPatterns = {
    // Horror subgenres
    'gothic': ['gothic', 'dark romanticism', 'victorian horror'],
    'psychological': ['psychological', 'mind', 'mental', 'psycho'],
    'supernatural': ['supernatural', 'paranormal', 'ghost', 'haunted', 'occult'],
    'cosmic': ['cosmic', 'lovecraftian', 'eldrich', 'cosmic horror'],
    'body horror': ['body horror', 'visceral', 'grotesque', 'medical horror'],
    
    // Fantasy subgenres
    'medieval': ['medieval', 'middle ages', 'feudal', 'knights', 'castles'],
    'urban fantasy': ['urban', 'modern fantasy', 'contemporary fantasy'],
    'high fantasy': ['high fantasy', 'epic fantasy', 'sword and sorcery'],
    'dark fantasy': ['dark fantasy', 'grimdark'],
    'fairy tale': ['fairy tale', 'folklore', 'myth', 'legend'],
    
    // Sci-Fi subgenres
    'dystopian': ['dystopian', 'post-apocalyptic', 'totalitarian'],
    'cyberpunk': ['cyberpunk', 'cyber', 'hacker', 'virtual reality'],
    'space opera': ['space opera', 'galactic', 'interstellar'],
    'hard sci-fi': ['hard science', 'scientific', 'technical'],
    'time travel': ['time travel', 'temporal', 'chronological'],
    
    // Mystery/Thriller subgenres
    'noir': ['noir', 'hard-boiled', 'detective'],
    'cozy mystery': ['cozy', 'amateur detective', 'village mystery'],
    'spy thriller': ['spy', 'espionage', 'intelligence'],
    'legal thriller': ['legal', 'courtroom', 'lawyer'],
    'medical thriller': ['medical', 'hospital', 'doctor'],
    
    // Romance subgenres
    'historical romance': ['historical', 'period', 'regency', 'victorian'],
    'paranormal romance': ['paranormal', 'vampire', 'werewolf', 'shapeshifter'],
    'contemporary romance': ['contemporary', 'modern'],
    'romantic suspense': ['suspense', 'danger', 'thriller'],
    
    // Literary themes
    'coming of age': ['coming of age', 'bildungsroman', 'young adult', 'adolescence'],
    'family saga': ['family', 'generational', 'multi-generational'],
    'war': ['war', 'military', 'battle', 'combat', 'wwii', 'vietnam'],
    'social commentary': ['social', 'political', 'society', 'class'],
    'existential': ['existential', 'philosophical', 'meaning of life'],
    
    // Settings/Atmospheres
    'small town': ['small town', 'rural', 'village', 'countryside'],
    'big city': ['city', 'urban', 'metropolitan', 'new york', 'london'],
    'isolated': ['isolated', 'remote', 'cabin', 'island', 'wilderness'],
    'academic': ['university', 'college', 'academic', 'professor', 'school'],
    'workplace': ['office', 'corporate', 'business', 'workplace']
  };
  
  // Check for tag matches
  Object.keys(tagPatterns).forEach(tag => {
    const patterns = tagPatterns[tag];
    if (patterns.some(pattern => text.includes(pattern))) {
      tags.push(tag);
    }
  });
  
  // Also include the original genre as a tag (normalized)
  tags.push(text.replace(/[^a-z\s]/g, '').trim());
  
  return [...new Set(tags)]; // Remove duplicates
}

function calculateTagOverlap(scannedTags, historyGenres) {
  if (!scannedTags.length || !historyGenres.length) {
    return { score: 0, matches: [] };
  }
  
  const matches = [];
  const historyTags = [];
  
  // Extract tags from all history genres
  historyGenres.forEach(genre => {
    const tags = extractTags(genre);
    historyTags.push(...tags);
  });
  
  // Find overlapping tags
  scannedTags.forEach(scannedTag => {
    historyTags.forEach(historyTag => {
      if (scannedTag === historyTag || 
          scannedTag.includes(historyTag) || 
          historyTag.includes(scannedTag)) {
        matches.push({ scanned: scannedTag, history: historyTag });
      }
    });
  });
  
  // Calculate overlap score (0 to 1)
  const uniqueMatches = [...new Set(matches.map(m => m.scanned))];
  const overlapScore = uniqueMatches.length / Math.max(scannedTags.length, 1);
  
  return {
    score: overlapScore,
    matches: uniqueMatches
  };
}

// Extract meaningful keywords from book descriptions
function extractKeywords(description) {
  if (!description) return [];
  
  // Common stop words to filter out
  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 
    'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 
    'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must',
    'this', 'that', 'these', 'those', 'his', 'her', 'their', 'he', 'she', 'it', 'they',
    'when', 'where', 'why', 'how', 'what', 'who', 'which', 'can', 'one', 'two', 'new',
    'old', 'first', 'last', 'good', 'great', 'best', 'book', 'story', 'novel', 'author'
  ]);
  
  // Meaningful keywords patterns (nouns, adjectives, thematic terms)
  const meaningfulPatterns = [
    // Settings & Places
    /\b(castle|palace|kingdom|village|city|forest|mountain|desert|ocean|island|space|planet|ship|station)\b/gi,
    /\b(medieval|victorian|modern|ancient|future|dystopian|utopian|magical|supernatural)\b/gi,
    /\b(academy|school|university|hospital|prison|mansion|cottage|tower|temple|church)\b/gi,
    
    // Characters & Relationships  
    /\b(prince|princess|king|queen|knight|warrior|wizard|witch|vampire|werewolf|dragon|demon|angel)\b/gi,
    /\b(detective|spy|assassin|thief|pirate|captain|doctor|scientist|professor|student)\b/gi,
    /\b(romance|love|marriage|friendship|family|betrayal|revenge|sacrifice|loyalty|honor)\b/gi,
    /\b(enemies|lovers|rivals|allies|mentor|apprentice|siblings|parents|children)\b/gi,
    
    // Themes & Concepts
    /\b(magic|power|curse|prophecy|destiny|fate|immortal|mortal|death|life|soul|spirit)\b/gi,
    /\b(war|battle|quest|journey|adventure|escape|survival|rescue|discovery|mystery)\b/gi,
    /\b(secret|hidden|forbidden|ancient|lost|forgotten|chosen|special|unique|rare)\b/gi,
    /\b(dark|light|shadow|blood|fire|ice|storm|night|dawn|time|memory|dream)\b/gi,
    
    // Emotions & Tone
    /\b(dangerous|deadly|haunting|beautiful|terrifying|mysterious|enchanting|forbidden)\b/gi,
    /\b(epic|intimate|heartbreaking|thrilling|suspenseful|romantic|comedic|tragic)\b/gi,
    /\b(complex|simple|twisted|pure|corrupt|innocent|wise|foolish|brave|cowardly)\b/gi,
    
    // Plot Elements
    /\b(conspiracy|investigation|heist|tournament|competition|ritual|ceremony|trial)\b/gi,
    /\b(rebellion|revolution|invasion|siege|alliance|treaty|betrayal|murder|theft)\b/gi,
    /\b(transformation|awakening|revelation|confrontation|sacrifice|redemption)\b/gi
  ];
  
  const keywords = new Set();
  
  // Extract pattern-based keywords
  meaningfulPatterns.forEach(pattern => {
    const matches = description.match(pattern);
    if (matches) {
      matches.forEach(match => keywords.add(match.toLowerCase().trim()));
    }
  });
  
  // Extract important adjectives and nouns (fallback for other meaningful words)
  const words = description.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length >= 4 && !stopWords.has(word))
    .filter(word => /^[a-z]+$/.test(word)); // Only alphabetic words
  
  // Add high-value words that might not match patterns
  words.forEach(word => {
    // Add words that appear in genre-defining contexts or are descriptive
    if (word.length >= 5 || 
        ['dark', 'lost', 'dead', 'wild', 'cold', 'deep', 'true', 'real'].includes(word)) {
      keywords.add(word);
    }
  });
  
  return Array.from(keywords).slice(0, 20); // Limit to top 20 keywords
}

// Calculate keyword overlap between descriptions
function calculateKeywordOverlap(keywords1, keywords2) {
  if (!keywords1.length || !keywords2.length) return { score: 0, matches: [] };
  
  const matches = keywords1.filter(keyword => keywords2.includes(keyword));
  const score = matches.length / Math.max(keywords1.length, keywords2.length, 1);
  
  // Bonus for multiple shared keywords (indicates strong thematic similarity)
  let bonusMultiplier = 1;
  if (matches.length >= 5) bonusMultiplier = 1.5;
  else if (matches.length >= 3) bonusMultiplier = 1.3;
  else if (matches.length >= 2) bonusMultiplier = 1.1;
  
  return { 
    score: Math.min(score * bonusMultiplier, 1), 
    matches: matches.slice(0, 5) // Show top 5 matches
  };
}

/* ========== OFFLINE RECOMMENDATION FUNCTIONS ========== */
function getOfflineRecommendationBonus(scannedBook, userHistory) {
  if (!bookDataset.length) return 0;
  
  let bonus = 0;
  const userReadTitles = new Set(userHistory.map(book => book.title.toLowerCase()));
  
  // Find matches in dataset by title or author
  const matches = findDatasetMatches(scannedBook);
  
  matches.forEach(match => {
    // If this exact book is in our dataset and has related books
    if (match.related && match.related.length > 0) {
      // Check if any related books match user's reading preferences
      match.related.forEach(relatedTitle => {
        const relatedBook = bookDataset.find(book => 
          book.title.toLowerCase() === relatedTitle.toLowerCase()
        );
        
        if (relatedBook && !userReadTitles.has(relatedBook.title.toLowerCase())) {
          // Bonus for unread related books
          bonus += 0.5;
          
          // Additional bonus if related book matches user's preferred genres/authors
          const userLikedBooks = userHistory.filter(book => Number(book.rating) >= 4);
          userLikedBooks.forEach(likedBook => {
            // Genre similarity bonus
            if (relatedBook.genres && likedBook.genre) {
              const likedGenres = likedBook.genre.split(',').map(g => g.trim().toLowerCase());
              const relatedGenres = relatedBook.genres.map(g => g.toLowerCase());
              
              if (likedGenres.some(lg => relatedGenres.some(rg => 
                rg.includes(lg) || lg.includes(rg)))) {
                bonus += 0.3;
              }
            }
            
            // Author similarity bonus
            if (relatedBook.authors && likedBook.author) {
              const relatedAuthors = relatedBook.authors.map(a => a.toLowerCase());
              const likedAuthor = likedBook.author.toLowerCase();
              
              if (relatedAuthors.some(ra => 
                ra.includes(likedAuthor) || likedAuthor.includes(ra))) {
                bonus += 0.5;
              }
            }
          });
        }
      });
    }
  });
  
  return Math.min(bonus, 3); // Cap the offline bonus at +3 points
}

function calculateScoreBreakdown(book, userHistory, rawScore, offlineBonus, preferenceScore) {
  const breakdown = {
    preferenceScore: preferenceScore || 0,
    offlineBonus: offlineBonus || 0,
    total: rawScore,
    scaledTotal: Math.min(Math.max(rawScore * 1.7, 0), 10)
  };
  
  if (!userHistory.length) {
    return {
      ...breakdown,
      explanation: "No reading history available for personalized scoring."
    };
  }
  
  // Calculate detailed preference breakdown
  let genreDetails = [];
  let authorDetails = [];
  
  if (book.categories) {
    book.categories.forEach(category => {
      const categoryLower = category.toLowerCase();
      const scannedTags = extractTags(category);
      
      const matchingBooks = userHistory.filter(histBook => {
        const histGenres = histBook.genre ? 
          histBook.genre.split(',').map(g => g.trim().toLowerCase()) : [];
        
        // Check both genre match and tag overlap
        const genreMatch = histGenres.some(hg => 
          hg.includes(categoryLower) || categoryLower.includes(hg)
        );
        const tagOverlap = calculateTagOverlap(scannedTags, histGenres);
        
        return genreMatch || tagOverlap.score > 0;
      });
      
      if (matchingBooks.length > 0) {
        const avgRating = matchingBooks.reduce((sum, book) => 
          sum + (Number(book.rating) || 3), 0) / matchingBooks.length;
        const ratingText = avgRating >= 4 ? "loved" : 
                          avgRating >= 3.5 ? "liked" : 
                          avgRating >= 2.5 ? "mixed feelings about" : "disliked";
        
        // Show specific tags that matched
        const tagMatches = [];
        matchingBooks.forEach(histBook => {
          const histGenres = histBook.genre ? 
            histBook.genre.split(',').map(g => g.trim().toLowerCase()) : [];
          const overlap = calculateTagOverlap(scannedTags, histGenres);
          if (overlap.matches.length > 0) {
            tagMatches.push(...overlap.matches);
          }
        });
        const uniqueTagMatches = [...new Set(tagMatches)];
        
        let detail = `${category}: You ${ratingText} ${matchingBooks.length} similar book${matchingBooks.length > 1 ? 's' : ''} (avg: ${avgRating.toFixed(1)}★)`;
        
        if (uniqueTagMatches.length > 0) {
          detail += ` - matched themes: ${uniqueTagMatches.slice(0, 3).join(', ')}${uniqueTagMatches.length > 3 ? '...' : ''}`;
        }
        
        genreDetails.push(detail);
      }
    });
  }
  
  if (book.authors) {
    const bookAuthors = book.authors.toLowerCase();
    const matchingBooks = userHistory.filter(histBook => {
      const histAuthor = histBook.author ? histBook.author.toLowerCase() : '';
      return histAuthor && (bookAuthors.includes(histAuthor) || histAuthor.includes(bookAuthors));
    });
    
    if (matchingBooks.length > 0) {
      const avgRating = matchingBooks.reduce((sum, book) => 
        sum + (Number(book.rating) || 3), 0) / matchingBooks.length;
      const ratingText = avgRating >= 4 ? "loved" : 
                        avgRating >= 3.5 ? "liked" : 
                        avgRating >= 2.5 ? "had mixed feelings about" : "disliked";
      
      const confidenceText = matchingBooks.length >= 3 ? "high confidence" : 
                           matchingBooks.length === 2 ? "moderate confidence" : "low confidence";
      
      authorDetails.push(`You ${ratingText} ${matchingBooks.length} book${matchingBooks.length > 1 ? 's' : ''} by this author (avg: ${avgRating.toFixed(1)}★, ${confidenceText})`);
    }
  }
  
  // Keyword-based thematic matching details
  const keywordDetails = [];
  if (book.description || book.subtitle) {
    const scannedDescription = (book.description || '') + ' ' + (book.subtitle || '');
    const scannedKeywords = extractKeywords(scannedDescription);
    
    if (scannedKeywords.length > 0) {
      // Find books with keyword matches
      const keywordMatches = [];
      userHistory.forEach(histBook => {
        const rating = Number(histBook.rating) || 3;
        
        if (rating >= 3.5 && histBook.title) {
          const historyDescription = histBook.title + ' ' + (histBook.genre || '');
          const historyKeywords = extractKeywords(historyDescription);
          const overlap = calculateKeywordOverlap(scannedKeywords, historyKeywords);
          
          if (overlap.score > 0 && overlap.matches.length > 0) {
            keywordMatches.push({
              book: histBook.title,
              rating: rating,
              matches: overlap.matches
            });
          }
        }
      });
      
      if (keywordMatches.length > 0) {
        const avgRating = keywordMatches.reduce((sum, match) => 
          sum + match.rating, 0) / keywordMatches.length;
        
        const allMatches = keywordMatches.reduce((acc, match) => 
          acc.concat(match.matches), []);
        const uniqueMatches = [...new Set(allMatches)];
        
        let detail = `Thematic similarity: Found ${keywordMatches.length} book${keywordMatches.length > 1 ? 's' : ''} with shared themes (avg: ${avgRating.toFixed(1)}★)`;
        detail += ` - keywords: ${uniqueMatches.slice(0, 4).join(', ')}${uniqueMatches.length > 4 ? '...' : ''}`;
        
        keywordDetails.push(detail);
      }
    }
  }
  
  return {
    ...breakdown,
    genreDetails,
    authorDetails,
    keywordDetails
  };
}

function findDatasetMatches(scannedBook) {
  if (!bookDataset.length) return [];
  
  const matches = [];
  const scannedTitle = scannedBook.title ? scannedBook.title.toLowerCase() : '';
  const scannedAuthors = scannedBook.authors ? scannedBook.authors.toLowerCase() : '';
  
  bookDataset.forEach(book => {
    let isMatch = false;
    
    // Title matching (exact or partial)
    if (book.title && scannedTitle) {
      const datasetTitle = book.title.toLowerCase();
      if (datasetTitle.includes(scannedTitle) || scannedTitle.includes(datasetTitle)) {
        isMatch = true;
      }
    }
    
    // Author matching
    if (!isMatch && book.authors && scannedAuthors) {
      book.authors.forEach(author => {
        const authorLower = author.toLowerCase();
        if (authorLower.includes(scannedAuthors) || scannedAuthors.includes(authorLower)) {
          isMatch = true;
        }
      });
    }
    
    if (isMatch) {
      matches.push(book);
    }
  });
  
  return matches;
}

/* ========== INIT ========== */
let bookDataset = [];
// Load offline book dataset for enhanced recommendations
async function loadBookDataset() {
  try {
    const response = await fetch('./bookwise_recommendations_dataset.json');
    bookDataset = await response.json();
    console.log(`Loaded ${bookDataset.length} books for offline recommendations`);
  } catch (error) {
    console.warn('Could not load offline book dataset:', error);
  }
}

showSaved();
showHistory();
loadBookDataset();
</script>
</body>
</html>
